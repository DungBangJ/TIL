# 지네릭스

다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다.

- 객체의 타입을 컴파일 시에 체크
  - 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다.
- 장점
  - 타입 안정성 제공
  - 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.

## 지네릭 클래스의 선언

일반적인 Box클래스를

```java
class Box{
  Object item;
  void setItem(Object item) { this.item = item ; }
  Object getItem() { return item; }
}
```

다음의 지네릭 클래스로 변경할 수 있다.

```java
class Box<T> { //지네릭 타입 T 선언
 T item;
 void setItem(T item) { this.item = item; }
 T getItem() { return item; }
}
```

T는 **타입 변수(type variable)** 이다.

- 기호와 종류를 다르게 쓸 수 있다.
  - 임의의 참조형 타입을 의미하는 것은 모두 같다.

*지네릭 클래스가 된 Box클래스의 객체를 생성할 때*는 다음과 같이 참조변수와 생성자에 타입 T대신에 사용될 실제 타입을 지정해줘야 한다.

```java
Box<String> b = new Box<String>();  //타입 T대신, 실제 타입을 지정
b.setItem(new Object());   //에러. String이외의 타입은 지정불가
b.setItem("ABC");     //String타입이므로 가능
String item = b.getItem();   //형변환 필요없다.
```

이렇게 타입 T대신에 String타입을 지정했으므로, 지네릭 클래스 Box는 다음과 같이 정의된 것과 같다.

```java
class Box{
  String item;
  void setItem(String item) { this.item = item ; }
  String getItem() { return item; }
}
```

지네릭 클래스를 사용할 때는 반드시 타입을 지정해서 지네릭스와 관련된 경고가 나오지 않게 하자.

### 지네릭스 용어

```java
class Box<T> {}
```

>- T: 타입 변수 또는 타입 매개변수.
>- Box:  원시 타입

```java
Box<String> b = new Box<String>();
```
지네릭 타입 호출
- 매개변수에 타입을 지정하는 것

매개변수화된 타입
- 대입된 타입
- 위의 코드에서 String을 지칭한다.

### 지네릭스의 제한
- 모든 객체에 대해 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수 없다.
  - T는 인스턴스 변수로 간주된다.
  - static멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야 하기 때문이다.
- 지네릭 타입의 배열을 생성하지 못한다.
  - 지네릭 배열 타입의 참조변수를 선언은 가능
```java
class Box<T> {
	T[] itemArr; //T타입의 배열을 위한 참조변수
		...
	T[] toArray() {
		T[] tmpArr = new T[itemArr.length];//지네릭 배열 생성불가
		...
		return tmpArr;
		...
	}
}
```
>new 연산자 때문에 지네릭 배열 생성 불가하다.
>new 연산자는 컴파일 시점에 타입 T가 정확히 뭔지 알아야 하는데 타입 T가 컴파일하는 시점에서는 어떤타입인지 전혀 알 수 없다 때문이다.
- instanceof연산자도 같은 이유로 T를 피연산자로 사용할 수 없다.
  - 꼭 지네릭 배열을 생성해야할 필요가 있을 때는, new연산자 대신 'Reflection API'의 newInstance()와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성

## 지네릭 클래스의 객체 생성과 사용
- 지네릭 클래스의 객체에는 T타입의 객체만 저장할 수 있다.
- 참조변수와 생성자에 대입된 타입(매개변수화된 타입)이 일치해야 한다.
- JDK1.7부터는 추정이 가능한 경우 타입을 생략할 수 있게 되었다.

```java
Box<Apple> appleBox = new Box<Apple>();
Box<Apple> appleBox = new Box<>(); // 같은 문장
```
- 대입된 타입과 다른 타입의 객체는 추가할 수 없다.
```java
Box<Apple> appleBox = new Box<Apple>();
appleBox.add(new Apple());
appleBox.add(new Grape()); //Box<Apple>에는 Apple의 객체만 추가가능
```
- 그러나 타입 T가 'Fruit'인 경우 Fruit의 자손들은 이 메서드의 매개변수가 될 수 있다.
```java
Box<Fruit> appleBox = new Box<Fruit>();
appleBox.add(new Fruit());
appleBox.add(new Grape());
appleBox.add(new Apple());
```
```java
package YJ;
import java.util.ArrayList;
public class YJ12_1 {
	public static void main(String[] args) {
		Box<Fruit> fruitBox = new Box<Fruit>();
		Box<Apple> appleBox = new Box<Apple>();
		Box<Toy> toyBox = new Box<Toy>();
		
		fruitBox.add(new Fruit());
		fruitBox.add(new Apple());
		appleBox.add(new Apple());
		appleBox.add(new Apple());
		toyBox.add(new Toy());
		
		System.out.println(fruitBox);
		System.out.println(appleBox);
		System.out.println(toyBox);
	}
}

class Fruit {public String toString() {return "Fruit";}}
class Apple extends Fruit {public String toString() {return "Apple";}}
class Grape extends Fruit {public String toString() {return "Grape";}}
class Toy {public String toString() {return "Toy";}}

class Box<T>{
	ArrayList<T> list = new ArrayList<T>();
	void add(T item) { list.add(item);}
	T get(int i) { return list.get(i);}
	int size() {return list.size();}
	public String toString() {return list.toString();}
}

// <Console>
// [Fruit, Apple]
// [Apple, Apple]
// [Toy]

```

## 제한된 지네릭 클래스
다음과 같이 extends를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
```java
class FruitBox<T extends Fruit>{ //Fruit의 자손만 타입으로 지정가능
	ArrayList<T> list = new ArrayLsit<T>();
	...
}
```
- 여전히 한 종류의 타입만 담을 수 있지만, Fruit클래스의 자손들만 담을 수 있다는 제한이 추가된 것이다.
- implement는 사용하지 않는다.

만약 클래스 Fruit의 자손이면서 Eatable인터페이스도 구현해야한다면 '&'기호로 연결한다.
```java
class FruitBox<T extends Fruit & Eatable>{...}
```
```java
package YJ;
import java.util.ArrayList;
public class YJ12_02 {
	public static void main(String[] args) {
		Box<Fruit> fruitBox = new Box<Fruit>();
		Box<Apple> appleBox = new Box<Apple>();
		Box<Grape> grapeBox = new Box<Grape>();
		
		fruitBox.add(new Fruit());
		fruitBox.add(new Apple());
		fruitBox.add(new Grape());
		appleBox.add(new Apple());
		grapeBox.add(new Grape());
		
		System.out.println("fruitBox-" + fruitBox);
		System.out.println("appleBox-" + appleBox);
		System.out.println("grapeBox-" + grapeBox);
	}
}
interface Eatable{};
class Fruit2 implements Eatable {public String toString() {return "Fruit";}}
class Apple2 extends Fruit {public String toString() {return "Apple";}}
class Grape2 extends Fruit {public String toString() {return "Grape";}}
class Toy2 {public String toString() {return "Toy";}}

class FruitBox<T extends Fruit & Eatable> extends Box<T>{}

class Box2<T>{
	ArrayList<T> list = new ArrayList<T>();
	void add(T item) { list.add(item);}
	T get(int i) { return list.get(i);}
	int size() {return list.size();}
	public String toString() {return list.toString();}
}

// <Console>
// fruitBox-[Fruit, Apple, Grape]
// appleBox-[Apple]
// grapeBox-[Grape]
```

## 와일드 카드
지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않는다.
- 지네릭 타입은 컴파일러가 컴파일 할 때만 사용하고 제거하기 때문에 결국에는 '메서드 중복 정의'가 된다.

그래서 나온 것이 **와일드 카드**이다.

```
<? extends T> 	T와 그 자손들만 가능
<? super T>		T와 그 조상들만 가능
<?>				제한 없음, 모든 타입 가능
```
> 지네릭 클래스와 달리 와일드 카드에는 '&'를 사용할 수 없다.

```java
package YJ;
import java.util.ArrayList;
public class YJ12_03 {
	public static void main(String[] args) {
		FruitBox3<Fruit> fruitBox = new FruitBox3<Fruit>();
		FruitBox3<Apple> appleBox = new FruitBox3<Apple>();
		
		fruitBox.add(new Apple());
		fruitBox.add(new Grape());
		appleBox.add(new Apple());
		appleBox.add(new Apple());
		
		System.out.println(Juicer.makeJuice(fruitBox));
		System.out.println(Juicer.makeJuice(appleBox));
	}
}
class Fruit3 {public String toString() {return "Fruit";}}
class Apple3 extends Fruit {public String toString() {return "Apple";}}
class Grape3 extends Fruit {public String toString() {return "Grape";}}

class Juice{
	String name;
	Juice(String name){ this.name = name + "Juice"; }
	public String toString() { return name; }
}

class Juicer{
	static Juice makeJuice(FruitBox3<? extends Fruit> box) {
		String tmp = "";
		for(Fruit f : box.getList())
			tmp += f + " ";
		return new Juice(tmp);
	}
}
class FruitBox3<T extends Fruit> extends Box3<T>{}

class Box3<T>{
	ArrayList<T> list = new ArrayList<T>();
	void add(T item) { list.add(item);}
	T get(int i) { return list.get(i);}
	ArrayList<T> getList() {return list;}
	int size() {return list.size();}
	public String toString() {return list.toString();}
}

// <Console>
// Apple Grape Juice
// Apple Apple Juice
```
