# java.lang패키지
- 가장 기본이 되는 클래스들을 포함하고 있다.
- import문 없이 사용 가능

# Object클래스 메서드
## equals(Object obj)
매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean값으로 알려 주는 역할을 한다.
- 두 객체의 같고 다름을 참조변수의 값으로 판단
  - 두 객체를 equals메서드로 비교하면 항상 false출력

```java
package YJ;

public class YJ9_01 {
	public static void main(String[] args) {
		Value v1 = new Value(10);
		Value v2 = new Value(10);
		
		if(v1.equals(v2)) //두 주소값을 비교하는 것이기 때문에 false
			System.out.println("v1과 v2는 같습니다.");
		else
			System.out.println("v1과 v2는 다릅니다.");
		
		v2 = v1; // v2에 v1의 인스턴스 주소값이 저장
		
		if(v1.equals(v2)) //v1, v2가 같은 주소를 참조하므로 같다. true
			System.out.println("v1과 v2는 같습니다.");
		else
			System.out.println("v1과 v2는 다릅니다.");
	}
}

class Value{
	int value;
	
	Value(int value){
		this.value = value;
	}
}

// <Console>
// v1과 v2는 다릅니다.
// v1과 v2는 같습니다.
```

```java
package YJ;
public class YJ9_02 {
	public static void main(String[] args) {
		Person p1 = new Person(1111L);
		Person p2 = new Person(1111L);
		
		if(p1 == p2) //객체의 주소를 비교한다.
			System.out.println("p1과 p2는 같은 사람입니다.");
		else
			System.out.println("p1과 p2는 다른 사람입니다.");
		
		if(p1.equals(p2)) //객체의 멤버 값을 비교한다.
			System.out.println("p1과 p2는 같은 사람입니다.");
		else
			System.out.println("p1과 p2는 다른 사람입니다.");
	}
}

class Person{
	long id;
	
	public boolean equals(Object obj) {
		if(obj instanceof Person)
			return id == ((Person)obj).id;
		else
			return false;
	}
	
	Person(long id){
		this.id = id;
	}
}

// <Console>
// p1과 p2는 다른 사람입니다.
// p1과 p2는 같은 사람입니다.
```

## hashCode()
이 메서드는 해싱(hashing)기법에 사용되는 '해시함수(hash function)'를 구현한 것이다.
- 해싱
  - 데이터관리 기법 중의 하나
  - 다량의 데이터를 저장하고 검색하는 데 유용
- 찾고자 하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환
- 객체의 주소값을 이용해서 해시코드를 만들어 반환
  - 두 객체는 결코 같은 해시코드를 가질 수 없다.

```java
package YJ;
public class YJ9_03 {
	public static void main(String[] args) {
		String str1 = new String("abc");
		String str2 = new String("abc");
		
		System.out.println(str1.equals(str2));
		System.out.println(str1.hashCode());
		System.out.println(str2.hashCode());
		System.out.println(System.identityHashCode(str1));
		System.out.println(System.identityHashCode(str2));
	}
}

// <Console>
// true
// 96354
// 96354
// 438135304
// 936580213
```
- String클래스는 문자열의 내용이 같으면, 동일한 해시코드를 반환
  - 이렇게 hashCode메서드가 오버라이딩 되었다.
- System.identityHashCode(Object x)
  - Object클래스의 hashCode메서드처럼 객체의 주소값으로 해시코드를 생성
    - 모든 객체에 항상 다른 해시코드 값을 반환

## toString()
인스턴스에 대한 정보를 문자열(String)로 제공
- 인스턴스 변수에 저장된 값들을 문자열로 표시
- toString()을 호출하면 클래스이름 + 16진수 해시코드를 얻게 된다.

```java
package YJ;
public class YJ9_04 {
	public static void main(String[] args) {
		Card c1 = new Card();
		Card c2 = new Card();
		
		System.out.println(c1.toString());
		System.out.println(c2.toString());
	}
}

class Card{
	String kind;
	int number;
	
	Card(){
		this("SPADE", 1);
	}
	Card(String kind, int number){
		this.kind = kind;
		this.number = number;
	}
}

// <Console>
// YJ.Card@1c4af82c
// YJ.Card@379619aa
```
- Card클래서에서 Object클래스로부터 상속받은 toString()을 오버라이딩 하지 않았다.
  - 그래서 Object클래스의 toString()이 호출된다.
    - 클래스이름 + 해시코드

```java
package YJ;
public class YJ9_05 {
	public static void main(String[] args) {
		Card1 c1 = new Card1();
		Card1 c2 = new Card1("HEART", 10);
		System.out.println(c1.toString());
		System.out.println(c2.toString());
	}
}

class Card1{
	String kind;
	int number;
	
	Card1(){
		this("SPADE", 1);
	}
	Card1(String kind, int number){
		this.kind = kind;
		this.number = number;
	}
	
	public String toString() {
		return "kind: " + kind + ", number: " + number;
	}
}

// <Console>
// kind: SPADE, number: 1
// kind: HEART, number: 10
```
- toString()을 오버라이딩 했다.
  - 조상에 정의된 접근범위 이상이어야 하므로 public

## clone()
자신을 복세하여 새로운 인스턴스를 생성한다.
- 원래의 인스턴스는 보존하고 clone메서드를 이용해서 새로운 인스턴스를 생성하여 작업을 하면 작업 이전의 값이 보존된다.
- Object클래스에 정의된 clone()은 단순히 인스턴스변수의 값만을 복사
  - 참조 타입의 인스턴스 변수가 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다.
  - 오버라이딩해야 한다.

```java
package YJ;
public class YJ9_06 {
	public static void main(String[] args) {
		Point original = new Point(3, 5);
		Point copy = (Point)original.clone();
		System.out.println(original);
		System.out.println(copy);
	}
}

class Point implements Cloneable{
	int x, y;
	Point(int x, int y){
		this.x = x;
		this.y = y;
	}
	public String toString() {
		return "x = " + x + ", y = " + y;
	}
	public Object clone() {
		Object obj = null;
		try {
			obj = super.clone();
		} catch (CloneNotSupportedException e) {}
		return obj;
	}
}

// <Console>
// x = 3, y = 5
// x = 3, y = 5
```
- clone()을 사용하려면, 먼저 복제할 클래스가 Cloneble인터페이스를 구현해야한다.
- clone()을 오버라이딩하면서 접근 제어자를 protected에서 public으로 변경한다.
  - 그래야만 상속관계가 없는 다른 클래스에서 clone()을 호출할 수 있다.

### 공변 반환타입(covariant return type)
오버라이딩할 때 조상 메서드의 반환타입을 자손 클래스의 타입으로 변경을 허용하는 것<br/>
원래는 오버라이딩할 때 조상에 선언된 메서드의 변환타입을 그대로 사용해야 했다.
```java
public Point clone(){ //반환타입을 Object에서 Point로 변경
    Object obj = null;
    try{
        obj = super.clone();
    } catch(CloneNotSupportedException e){}
    return (Point)obj; //Point타입으로 형변환 가능
}
```
- 이렇게 반환타입으로 자손 타입 가능


```java
package YJ;

import java.util.Arrays;

public class YJ9_08 {
	public static void main(String[] args) {
		int[] arr = {1,2,3,4,5};
		int[] arrClone = arr.clone();//배열 arr을 복제해서 같은 내용의 새로운 배열 생성
		arrClone[0] = 6;
		
		System.out.println(Arrays.toString(arr));
		System.out.println(Arrays.toString(arrClone));
	}
}

// <Console>
// [1, 2, 3, 4, 5]
// [6, 2, 3, 4, 5]
```
- clone()을 이용해서 배열을 복사하는 예제
  - 배열도 객체
    - Object클래스 상속, Cloneable, Serializable인터페이스 구현되어 있다.
      - Object클래스의 멤버들 모두 상속
      - 배열에서는 clone()을 public으로 오버라이딩 했다.
        - 직접 호출가능
      - 원본과 같은 타입을 반환
        - 형변환 불필요
- 배열 복사 방법 2가지
  - 같은 길이의 새로운 배열을 생성 후에 System.arraycopy()
  - clone()을 이용해서 간단히 복사

```java
int[] arr = {1,2,3,4,5};
int[] arrClone = arr.clone();
```
↓↓↓↓↓↓↓↓↓
```java
int[] arr = {1,2,3,4,5};
int[] arrClone = new int[arr.length];
System.arrcopy(arr, 0, arrClone, 0, arr.length);
```

### 얕은 복사와 깊은 복사