- [인터페이스](#인터페이스)
  - [인터페이스 상속](#인터페이스-상속)
  - [인터페이스 구현](#인터페이스-구현)
  - [인터페이스 레퍼런스를 통해 구현체를 사용하는 방법(인터페이스를 이용한 다형성)](#인터페이스-레퍼런스를-통해-구현체를-사용하는-방법인터페이스를-이용한-다형성)
  - [인터페이스의 (default) 메서드, static 메서드](#인터페이스의-default-메서드-static-메서드)
  - [인터페이스의 private 메서드](#인터페이스의-private-메서드)

# 인터페이스

- 오직 추상메서드와 상수만을 멤버로 가질 수 있다.
- 인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다.
  - public, (default)만 접근제저자로 가능
- 인터페이스 vs 추상클래스
  |         인터페이스         |               추상클래스               |
  | :------------------------: | :------------------------------------: |
  | 아무것도 없이 추상메서드만 | 일반클래스인데 추상메서드를 갖고 있다. |

```java
interface 인터페이스이름 {
    public static final 타입 상수이름  = 값 ;
    public abstract 메서드이름(메서드목록);
}
```

- 모든 멤버변수는 public static final 이어야하며, 생략 가능
- 모든 메서드는 public abstract 이어야하며, 생략 가능
- 장점
  - 개발시간 단축
  - 표준화 가능
  - 관계없는 클래스들의 중매자
  - 독립적인 프로그래밍 가능
    - 선언부와 구현부가 독립적이라서 클래스를 수정할때 용이하다.

## 인터페이스 상속

- 인터페이스는 인터페이스로부터 상속받을 수 있으며, 다중상속도 가능하다.
  - 다중상속이 가능한 이유
    - 메서드의 선언부가 같아도 구현부가 없는 추상메서드를 상속받는 것이기 때문에 충돌 없이 다중상속이 가능한 것이다.
- 인터페이스는 최고 조상이 없다.

## 인터페이스 구현

- 인터페이스 완성시키기
- 인터페이스도 추상클래스처럼 자신에게 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다.
- 인터페이스를 구현하는 클래스의 extends 자리에 **implements**를 사용해 구현한다.
- 인터페이스를 구현하는 메서드가 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.

## 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법(인터페이스를 이용한 다형성)

|                         다형성                          |                                    인터페이스                                     |
| :-----------------------------------------------------: | :-------------------------------------------------------------------------------: |
| 자손클래스의 인스턴스를 조상타입의 참조변수로 참조 가능 | 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다. |

```java
Fightable f = new Fighter();
//Fightable: 인터페이스, Fighter: Fighable 인터페이스를 구현한 클래스

void attack(Fightable f){
    //인터페이스는 매개변수로도 사용가능하다.
}
```

- **인터페이스를 매개변수로 가지면, 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다.**

```java
Fightable method(){
    ...
    Fighter f = new Fighter();
    return f;
}
```

- **리턴타입이 인터페이스라는 것은 해당 메서드가 반환타입으로 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것이다.**

## 인터페이스의 (default) 메서드, static 메서드

인터페이스에는 추상메서드만 선언할 수 있었다.

- JDK1.8부터 (default), static 메서드 추가
- static 메서드
  - 인스턴스와 관계없는 독립적인 메서드이기 때문에 예전부터 인터페이스에 추가하지 못할 이유가 없었다.
- (default) 메서드
  - 인터페이스에 메서드를 추가한다는 것은, 인터페이스를 구현한 모든 클래스에서 다시 추가된 메서드를 구현해야 한다는 어려움을 가져온다.
    - 그래서 구현할 필요없는 (default) 메서드를 추가하여 인터페이스에 메서드를 추가하더라도 다른 구현 클래스들에게 부담을 덜어준다.

## 인터페이스의 private 메서드

**why?**

- java 8 의 default method와 static method는 여전히 불편하게 만든다.
- 단지 특정 기능을 처리하는 내부 method일 뿐인데도, **외부에 공개되는 public method로 만들어야 하기 떄문이다.**
- interface를 구현하는 다른 interface 혹은 class가 해당 method에 엑세스 하거나 상속할 수 있는것을 원하지 않지만, 그렇게 될 수 있는 것이다.

**private 메소드의 네가지 규칙**

- private 메소드는 구현부를 가져야만 한다.
- 오직 인터페이스 내부에서만 사용할 수 있다.
- private static 메소드는 다른 static 또는 static이 아닌 메소드에서 사용할 수 있다.
- static이 아닌 private 메소드는 다른 private static 메소드에서 사용할 수 없다.
