# 클래스(class)

- 객체를 정의하는 틀, 설계도
  - 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 하고, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
- 데이터 + 함수
  - 속성 + 기능
- 사용자 정의 타입

다음과 같은 선언부만 있는 클래스도 아주 중요한 기능인 객체를 만들 수 있다.
```java
public class Animal {
}

Animal cat = new Animal();
```
 
# 객체
- 클래스를 사용하기 위해 해당 클래스 타입의 객체를 선언해야 한다.
  - 이렇게 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스화라고 한다.
  - 선언된 해당 클래스 타입의 객체를 인스턴스라고 한다.
    - 인스턴스 = 메모리에 할당된 객체
- 클래스명 변수명 = new 클래스명();
  - 인스턴스 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.
- 객체 생성 과정 ```Tv t = new Tv();```
  1. Tv t
  	Tv 클래스 타입의 참조변수 t를 선언한다.
    메모리에 참조변수 t를 위한 공간이 할당된다.
  2. t = new Tv();
  	**연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간이 생성된다.**
    대입연산자(=)에 의해 Tv클래스의 인스턴스의 주소값이 참조변수 t에 저장된다. 이렇게 되면 **Tv클래스의 인스턴스는 참조변수 t에 의해서만 접근할 수 있다.**
    
    
# 메소드
- 클래스 내에 구현된 함수
- 특정 작업을 수행하는 일련의 문장 집합
- 함수와 다른점
  - 함수와 달리 입력값 또는 출력값이 없어도 된다.
  - 심지어 둘 다 없어도 된다.
- 매개변수 선언시에 주의할 점
  - 일반적인 변수선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다.
```java
  int add(int x, int y) {}
  int add(int x, y) {} //에러, 매개변수 타입 y의 타입이 없다.

```
- 메소드의 반환타입이 void가 아닌 경우라면, 반드시 return문을 포함하고 있어야 한다.
  - 이 때 반환 값의 타입은 반환타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.
  - 반환값은 오직 하나다.
- 메소드는 호출되지 않으면 아무 일도 일어나지 않는다.
  - main 메소드는 프로그램 실행 시 OS에 의해 자동적으로 호출된다.
- 메소드를 호출할 때 괄호() 안에 지정해준 값을 '인수(argument)'라고 한다.
  - 이 인수의 개수와 순서는 메소드에 선언된 매개변수와 일치해야 한다.
- 메소드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
  - 메소드 호출시간이 짧아지므로 성능이 향상된다.
  - static을 붙이지 않은 메서드(인스턴스 메소드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.
- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면, static을 붙여준다.

## 매개변수(기본형, 참조형)
  - 기본형 매개변수: 기본형 값이 복사된다.
    - 매개변수를 기본형으로 선언하면 단순히 저장된 값만 불러온다.(read)
  - 참조형 매개변수: 인스턴스의 주소가 복사된다.
    - 매개변수를 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물론 _**값을 변경하는 것도 가능하다.**_(read & write)
    
## 메서드 간의 호출과 참조
- 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.
   - 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.
   - 하지만, 클래스 메서드는 인스턴스 메서드를 호출할 수 없다.
     - 클래스 메서드는 인스턴스화를 하지 않기 때문
     
## 오버로딩
- 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다.
- 규칙
  - 메서드 이름이 같아야 한다.
  - 매개변수의 개수 또는 타입이 달라야 한다.
  - 반환 타입은 상관없다.
  
# 생성자
- 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'
- 인스턴스 변수 초기화 작업에 주로 사용
- 인스턴스 생성 시에 실행되어야 하는 작업을 위해서도 사용
- 리턴값이 없다. 그렇다고 void를 쓰는 것도 아니다. 그냥 없다.
  - 생성자도 메소드이기 때문에 void를 써야하지만, 모든 생성자가 리턴값이 없기 때문에 그냥 생략해버리는 것이다.
- 규칙
  - 생성자의 이름 = 클래스의 이름
  - 리턴값 없다.
  
## 기본 생성자
- 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유
  - 컴파일러가 제공하는 '기본 생성자(default constructor)' 덕분
  - 기본 생성자: ```클래스이름(){}```
  - _**클래스에 정의된 생성자가 하나도 없을 경우에만, 컴파일러가 자동으로 기본 생성자를 추가 해준다.**_
  
## 매개변수가 있는 생성자
- 인스턴스를 생성하는 동시에 원하는 값으로 초기화 가능
※인스턴스를 생성할 때 고려사항
  - 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
  - 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?
```java
public class JustExer {

	public static void main(String[] args) {
		Car c1 = new Car(); //기본 생성자 사용
		c1.color = "white";
		c1.gearType = "auto";
		c1.door = 4;
		
		Car c2 = new Car("white", "auto", 4); //매개변수가 있는 생성자 사용		
	}
}

class Car {
	String color;
	String gearType;
	int door;
	
	Car(){}
	Car(String c, String g, int d){
		color = c;
		gearType = g;
		door = d;
	}
}
```

### 생성자에서 다른 생성자 호출하기 - this()
- 같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.
  - 생성자의 이름으로 클래스의 이름 대신 this()를 사용해 호출한다.
  - 한 생성자에서 다른 생성자를 호출할 때는 반드시 _**첫 줄에서만 호출이 가능하다.**_
```java

public class JustExer {

	public static void main(String[] args) {
		Car c1 = new Car();
		Car c2 = new Car("blue");		
	}
}

class Car {
	String color;
	String gearType;
	int door;
	
	Car(){
		this("white", "auto", 4); //기본 생성자를 생성할 때 매개변수가 있는 생성자를 생성할 때와 같은 효과를 볼 수 있다.
	}
	
	Car(String color){
		this(color, "auto", 4);
	}
	
	Car(String color, String gearType, int door){
		this.color = color;
		this.gearType = gearType;
		this.door = door;   // 그냥 door = d 라고 해도 되지만, 매개변수를 door로 받아서 혼동이 없도록 this.door로 써준 것이다.
	}
}
```

# this
- 객체 자신을 가리키는 참조 변수
- 인스턴스 멤버만 this를 사용할 수 있다.
- 인스턴스의 주소가 저장되어 있다.
- 모든 인스턴스 메소드에 지역변수로 숨겨진 채로 존재한다.
- 대부분 지역변수와 인스턴스변수를 구별할 때 사용한다.
- **_this와 this()는 비슷하게 생겼을 뿐 완전히 다른 것이다._**
  - this는 **참조변수**
  - this()는 **생성자**

  
    
