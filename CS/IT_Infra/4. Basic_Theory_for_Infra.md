- [직렬/병렬](#직렬병렬)
  - [사용하는 곳](#사용하는-곳)
    - [웹 서버와 AP 서버에서의 병렬화](#웹-서버와-ap-서버에서의-병렬화)
  - [DB 서버에서의 병렬화](#db-서버에서의-병렬화)
  - [정리](#정리)
- [동기/비동기](#동기비동기)
  - [사용되는 곳](#사용되는-곳)
    - [DBMS에서 사용되는 비동기 I/O](#dbms에서-사용되는-비동기-io)
  - [정리](#정리-1)
- [큐](#큐)
  - [사용되는 곳](#사용되는-곳-1)
- [배타적 제어](#배타적-제어)
  - [사용되는 곳](#사용되는-곳-2)
    - [DBMS에서 사용되는 배타적 제어](#dbms에서-사용되는-배타적-제어)
    - [OS 커널에 사용되는 배타적 제어](#os-커널에-사용되는-배타적-제어)
    - [클러스터 데이터베이스의 배타적 제어](#클러스터-데이터베이스의-배타적-제어)
  - [정리](#정리-2)
- [상태 저장/상태 비저장](#상태-저장상태-비저장)
  - [사용되는 곳](#사용되는-곳-3)
    - [컴퓨터 내부 구조](#컴퓨터-내부-구조)
    - [네트워크 통신 구조](#네트워크-통신-구조)

---

# 직렬/병렬

분담할 수 있는 처리는 CPU 코어를 늘리면 빨라진다.
- 병렬화하면 가능

분담할 수 없는 처리는 CPU 코어를 늘려도 빨라지지 않는다.
- 직렬화하면 가능

직렬 처리

- 속도를 올리는 데 한계가 있다.

병렬 처리

- 속도는 빨라지지 않지만, 단위 시간당 처리량을 늘릴 수 있다.
  - 합류점, 직렬화 구간, 분기점이 병목 지점이 될 수 있다.
  - 병렬화할 때는 일을 분담해서 처리한 후 다시 집약할 때 오버헤드가 걸린다.
    - 오버헤드를 감당하더라도 효과가 있을 경우 병렬화를 한다.

## 사용하는 곳

### 웹 서버와 AP 서버에서의 병렬화

웹 서버

- 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리를 한다.

AP 서버

- JVM은 프로세스가 하나이지만 복수의 스레드가 병렬로 처리한다.
- 운영체제에서의 작업 단위는 프로세스이지만, CPU에서의 작업 단위는 프로세스로부터 전달받은 하나의 스레드이다.
- 아무리 프로세스를 늘려도 CPU 코어가 한개밖에 없다면 동시에 실행할 수 있는 것은 1 프로세스 뿐인 것이다.
  - 프로세스나 스레드 수를 조정할 때는 CPU 코어 수도 함께 고려해야 한다.

## DB 서버에서의 병렬화

서버 프로세스

- 클라이언트 요청을 처리
- 복수의 프로세스로 병렬화 되어있다.

공유 서버형

- 하이브리드형
- 멀티 프로세스와 멀티 스레드를 모두 사용할 수 있다.

DBWR(Database Writer) 프로세스

- 메모리에서 변경된 버퍼를 디스크에 기록하는 프로세스
- 데이터 파일 생성 시에 병목 현상이 생길 경우
  - 프로세스를 늘려서 병렬로 I/O를 실시할 수 있다.
  - 프로세스를 늘리는 방법 외에도 비동기 I/O를 사용해서 OS 측에서의 쓰기 처리를 병렬화하는 방법도 있다.

오라클 DB

- 클라이언트 요청을 접수하는 서버 프로세스가 클라이언트 접속 수만큼 생성된다.

## 정리

직렬/병렬의 장단점

||장점|단점|
|:---|:---|:---|
|직렬|구조 간단, 구현 난이도 낮음|복수의 리소스를 유용하게 사용할 수 없다.|
|병렬|복수의 리소스 유용하게 이용 가능, 직렬에 비해 동일 시간당 처리량이 증가, 일부가 고장나더라도 처리 지속 가능|처리 분기나 합류를 위한 오버헤드 발생 가능, 구조 복잡, 구현 난이도 높음|

병렬화 시 주의 사항

- 병렬 처리에서는 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다.
- 병렬화가 유효한 지역을 파악해서병렬화 해야한다.
  - 오버헤드나 구조 복잡화 등의 단점보다 병렬화로 가질 수 있는 이득이 더 클 때만 병렬화를 진행한다.

---

# 동기/비동기

동기

- 누군가에게 일을 부탁하고 그 일이 끝나기까지 기다리는 것
- 의뢰한 것이 끝났는지 여부를 확실하게 알 수 있다.

비동기

- '끝나면 말해'라고 말해 두고 다른 일을 하는 것
- 의뢰한 것이 끝났는지 여부를 확인하고 싶으면 별도의 방법을 이용해야 한다.
- 비동기에서는 처리를 병행해서 진행할 수 있다.

## 사용되는 곳

AJAX

- 비동기 통신을 이용한 병렬 처리 가능
- AJAX를 사용한 웹 페이지에서는 비동기 통신이 가능해져서 화면을 보거나 입력하면서 필요한 부분만 갱신할 수 있다.

### DBMS에서 사용되는 비동기 I/O

DBMS는 HDD 등의 저장소에 비동기로 쓰기 처리 가능

- 공유 메모리에 있는 다수의 데이터를 프로세스가 HDD에 기록할 경우
  - 비동기 I/O로 여러 I/O를 실행하여 저장소 성능을 충분히 사용할 수 있다.

## 정리

동기/비동기의 장단점

||장점|단점|
|:---|:---|:---|
|동기|구조 간단, 구현 난이도 낮음, 의뢰한 처리가 끝났는지 여부 쉽게 확인 가능|의뢰한 처리가 끝날 때까지 아무것도 안하고 기다려야 한다.|
|비동기|의뢰한 처리가 진행되고 있는 동안 다른 의뢰를 병렬 처리하여 시간을 효율적으로 활용 가능|의뢰가 끝났는지 확인하기 위한 추가적인 확인 처리가 필요, 구조 복잡, 구현 난이도 높음|

---

# 큐

대기 행렬, FIFO(First In First Out)

## 사용되는 곳

- CPU 처리를 기다리고 있는 프로세스나 스레드 행렬
  - 런큐(Run-queue)
    - CPU를 기다리고 있는 프로세스 행렬
    - 런큐에 쌓인 프로세스 수를 코어 수로 나누어서 1이하이면 처리지연 문제로 보지 않는다.(일반적으로)
    - 리눅스에서는 코어에서 실행 중인 프로세스도 런큐로 인식한다.
    - OS 커널에서 프로세스 스케쥴러 기능으로 런큐를 관리한다.
- 하드 디스크 등의 저장소 읽기 처리를 기다리고 있는 I/O 요구 행렬
  - 데이터베이스의 디스크 I/O
- 네트워크 접속 성립을 기다리고 있는 접속 요구 행렬

---

# 배타적 제어

다른 것을 배제하는 제어
- 여러 사람이 공유하기 때문에 배타적 제어가 필요한 것
- 직렬 처리에서는 필요없지만, 병렬 처리에서는 필요하다.
  - 일반적으로 OS나 DBMS 병렬처리에 사용

병렬 처리 시에 각 처리가 독립적으로 동작한다면 배타적 제어가 필요 없지만, 대부분은 공유 데이터를 이용하고, 부분적으로 직렬 처리를 사용한다.
- 이럴 때 배타적 제어가 필요

복수의 처리가 공유 자원(CPU, 디스크 등)에 동시에 액세스하면 불일치가 발생할 수 있기 때문에 배타적 제어로 보호해줘야 한다.
- 특정 처리가 공유 자원을 이용하고 있는 동안 다른 처리가 이용할 수 없게 해서 불일치 발생을 억제한다.
  - 다른 처리가 기다리는 동안 병목 현상이 발생

## 사용되는 곳

### DBMS에서 사용되는 배타적 제어

오라클 DB
- 특정 프로세스가 공유 데이터를 변경하는 도중에 다른 프로세스가 해당 공유 데이터에 접근하지 못하게 배타적 제어

래치(Latch), 스핀 락(Spin-lock)
- DBMS의 배타적 제어에서 매우 짧은 시간 동안만 락(Lock)을 유지하는 것
- CPU에서 의미 없는 처리를 하며 대기한다.
- 컨텍스트 스위칭이 일어나지 않는다.

슬릭 락(Sleep-lock)
- 비교적 장시간 락을 유지하도록 큐를 이용해서 관리하는 방식

어댑티브 락(Adaptive-lock)
- 상황에 따라 스핀할지 슬립할지를 판단하는 방식
- 슬립해서 기다리면 컨텍스트 스위치가 발생
  - 극히 단시간의 락에서는 스핀락이 사용된다.

### OS 커널에 사용되는 배타적 제어

빅 커널락(Big Kernel Lock, BKL)
- 리눅스 커널의 스핀락
- 커널의 BKL이 이용되는 부분에서는 처리가 직렬화된다.
  - 동시에 하나의 CPU만 커널 코드를 실행할 수 있다.
  - 병목 지점이 되기 쉽다.
- 컴퓨터가 여러 코어를 유용하게 활용해서 병렬 실행 가능한 처리를 늘리기 위해  리눅스 커널에서는 BKL로 보호된 커널 코드를 수정했다.
  - 락 단위를 세분화해서 병렬 성능을 향상시켰다.
  - 빅 커널락이 없다면 배타적 제어가 어려울 수 있다.
- CPU가 하나 밖에 없으면 동시에 처리할 수 있는 프로세스가 한 개이므로 다른 프로세스는 CPU를 사용할 수 없다.
  - 스핀락 불필요
### 클러스터 데이터베이스의 배타적 제어

액티브-액티브(Active-Active) 클러스터 DB
- 여러 대의 DB 서버를 조합해서 하나의 데이터베이스로 사용
- 서버 간 데이터 교환을 얼마나 줄일 수 있는지가 중요하다.
  - 배타적 제어에 의한 대기 상태를 최대한 줄여야 한다.
## 정리

배타적 제어의 장단점

||장점|단점|
|:--|:--|:--|
|배타적 제어 X|공유 데이터의 일관성 유지 가능|병렬 처리가 안된다.|
|배타적 제어 O|병렬로 빠리게 처리 가능|데이터 불일치 발생 가능|

필요 이상으로 배타적 제어를 사용하면 CPU가 여러 개 있더라도 하나밖에 사용할 수 없게 된다.
- 정말로 필요한 곳에만 쓴다면 CPU를 유용하게 활용해서 처리 속도를 높일 수 있다.

---

# 상태 저장/상태 비저장

상태 저장(Stateful)
- 정보를 많이 가지고 있다.
  - 세분화된 제어 가능
  - 구조 복잡
- ssh
  - 상태 저장 프로토콜
- 부여된 정보에 따라 '상태'가 전이된다.
  - 과거의 정보를 가져올 수 있어서 정보에 따른 복잡한 처리 가능(장점)
  - 시스템 복잡성이 커진다.(단점)

상태 비저장(Stateless)
- 고기능은 아니지만 간단
- http
  - 상태 비저장 프로토콜
  - 간단한 구조로 인해 성능이나 안전성을 쉽게 향상시킬 수 있다.(장점)
  - 과거 정보를 가져올 수 없어서 복잡한 처리가 어렵다.(단점)
    - 필요한 정보는 처리할 때마다 매번 전달돼야 한다.

어떤 작업을 하고 있을 때 현재 어디까지 작업이 진행됐는지와 같은 '상태'를 알아야 하는 경우가 있다.

'상태'를 가진다는 것은 과거에 부여한 '정보'를 저장해서 계속 활용할 수 있다는 것을 의미한다.

## 사용되는 곳

### 컴퓨터 내부 구조

일반적으로 CPU는 하나의 CPU에서 복수의 프로세스를 조금씩 처리한다.
- 처리하고 있는 프로세스는 1코어당 하나
  - 처리하지 않는 프로세스는 대기 상태

프로세스 상태 전이 과정

1. 어떤 명령이나 애플리케이션을 실행
   - 프로세스 생성, 프로세스 실행이 '개시'된다.
2. 실행 큐라 불리는 순서 대기 행렬에서 대기
   - '실행 가능 상태'
3. 차례가 되면 '실행 상태'로 전이
   - 애플리케이션 처리
   - 하나의 프로세스가 CPU를 독점하지 않고, 일정량을 처리하면 CPU에서 나온다.
4. 다시 순서 행렬에서 대기한다.
   - 만약 I/O 대기가 발생하는 처리를 실행한 경우 '대기 상태'로 전이
5. 2 ~ 4 과정을 반복하다가 처리가 끝나면 '종료'

### 네트워크 통신 구조

HTTP
- 상태 비저장 프로토콜
- 상태가 없기 때문에 매번 같은 데이터를 반환
- 유저의 정보 같은 것은 저장을 해야한다.
  - HTTP에서는 세션(Session)이라는 개념을 사용해서 이 구조를 구현한다.
- 로그인 등의 인증을 거치면 서버는 그 상태를 저장함과 동시에 인증 완료 세션 정보를 반환한다.
  - 인증을 끝낸 사용자는 통신 시에 이 세션 정보를 서버에 건네기만 하면 이전 처리 상태를 유지하면서 접속할 수 있다.