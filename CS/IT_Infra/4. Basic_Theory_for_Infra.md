- [직렬/병렬](#직렬병렬)
	- [사용하는 곳](#사용하는-곳)
		- [웹 서버와 AP 서버에서의 병렬화](#웹-서버와-ap-서버에서의-병렬화)
	- [DB 서버에서의 병렬화](#db-서버에서의-병렬화)
	- [정리](#정리)
- [동기/비동기](#동기비동기)
	- [사용되는 곳](#사용되는-곳)
		- [DBMS에서 사용되는 비동기 I/O](#dbms에서-사용되는-비동기-io)
	- [정리](#정리-1)
- [큐](#큐)
	- [사용되는 곳](#사용되는-곳-1)
- [배타적 제어](#배타적-제어)

---

# 직렬/병렬

분담할 수 있는 처리는 CPU 코어를 늘려민 빨라진다.

분담할 수 없는 처리는 CPU 코어를 늘려도 빨라지지 않는다.

직렬 처리

- 속도를 올리는 데 한계가 있다.

병렬 처리

- 속도는 빨라지지 않지만, 단위 시간당 처리량을 늘릴 수 있다.
  - 합류점, 직렬화 구간, 분기점이 병목 지점이 될 수 있다.
  - 병렬화할 때는 일을 분담해서 처리한 후 다시 집약할 때 오버헤드가 걸린다.
    - 오버헤드를 감당하더라도 효과가 있을 경우 병렬화를 한다.

## 사용하는 곳

### 웹 서버와 AP 서버에서의 병렬화

웹 서버

- 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리를 한다.

AP 서버

- JVM은 프로세스가 하나이지만 복수의 스레드가 병렬로 처리한다.
- 운영체제에서의 작업 단위는 프로세스이지만, CPU에서의 작업 단위는 프로세스로부터 전달받은 하나의 스레드이다.
- 아무리 프로세스를 늘려도 CPU 코어가 한개밖에 없다면 동시에 실행할 수 있는 것은 1 프로세스 뿐인 것이다.
  - 프로세스나 스레드 수를 조정할 때는 CPU 코어 수도 함께 고려해야 한다.

## DB 서버에서의 병렬화

서버 프로세스

- 클라이언트 요청을 처리
- 복수의 프로세스로 병렬화 되어있다.

공유 서버형

- 하이브리드형
- 멀티 프로세스와 멀티 스레드를 모두 사용할 수 있다.

DBWR(Database Writer) 프로세스

- 메모리에서 변경된 버퍼를 디스크에 기록하는 프로세스
- 데이터 파일 생성 시에 병목 현상이 생길 경우
  - 프로세스를 늘려서 병렬로 I/O를 실시할 수 있다.
  - 프로세스를 늘리는 방법 외에도 비동기 I/O를 사용해서 OS 측에서의 쓰기 처리를 병렬화하는 방법도 있다.

오라클 DB

- 클라이언트 요청을 접수하는 서버 프로세스가 클라이언트 접속 수만큼 생성된다.

## 정리

직렬/병렬의 장단점

||장점|단점|
|:---|:---|:---|
|직렬|구조 간단, 구현 난이도 낮음|복수의 리소스를 유용하게 사용할 수 없다.|
|병렬|복수의 리소스 유용하게 이용 가능, 직렬에 비해 동일 시간당 처리량이 증가, 일부가 고장나더라도 처리 지속 가능|처리 분기나 합류를 위한 오버헤드 발생 가능, 구조 복잡, 구현 난이도 높음|

병렬화 시 주의 사항

- 병렬 처리에서는 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다.
- 병렬화가 유효한 지역을 파악해서병렬화 해야한다.
  - 오버헤드나 구조 복잡화 등의 단점보다 병렬화로 가질 수 있는 이득이 더 클 때만 병렬화를 진행한다.

---

# 동기/비동기

동기

- 누군가에게 일을 부탁하고 그 일이 끝나기까지 잠자고 기다리는 것
- 의뢰한 것이 끝났는지 여부를 확실하게 알 수 있다.

비동기

- '끝나면 말해'라고 말해 두고 다른 일을 하는 것
- 의뢰한 것이 끝났는지 여부를 확인하고 싶으면 별도의 방법을 이용해야 한다.
- 비동기에서는 처리를 병행해서 진행할 수 있다.

## 사용되는 곳

AJAX

- 비동기 통신을 이용한 병렬 처리 가능
- AJAX를 사용한 웹 페이지에서는 비동기 통신이 가능해져서 화면을 보거나 입력하면서 필요한 부분만 갱신할 수 있다.

### DBMS에서 사용되는 비동기 I/O

DBMS는 HDD 등의 저장소에 비동기로 쓰기 처리 가능

- 공유 메모리에 있는 다수의 데이터를 프로세스가 HDD에 기록할 경우
  - 비동기 I/O로 여러 I/O를 실행하여 저장소 성능을 충분히 사용할 수 있다.

## 정리

동기/비동기의 장단점

||장점|단점|
|:---|:---|:---|
|동기|구조 간단, 구현 난이도 낮음, 의뢰한 처리가 끝났는지 여부 쉽게 확인 가능|의뢰한 처릭 끝날 때까지 아무것도 안하고 기다려야 한다.|
|비동기|의뢰한 처리가 진행되고 있는 동안 다른 의뢰를 병렬 처리하여 시간을 효율적으로 활용 가능|의뢰가 끝났는지 확인하기 위한 추가적인 확인 처리가 필요, 구조 복잡, 구현 난이도 높음|

---

# 큐

대기 행렬, FIFO(First In First Out)

## 사용되는 곳

- CPU 처리를 기다리고 있는 프로세스나 스레드 행렬
  - 런큐(Run-queue)
    - CPU를 기다리고 있는 프로세스 행렬
    - 런큐에 쌓인 프로세스 수를 코어 수로 나누어서 1이하이면 처리지연 문제로 보지 않는다.(일반적으로)
    - 리눅스에서는 코어에서 실행 중인 프로세스도 런큐로 인식한다.
    - OS 커널에서 프로세스 스케쥴러 기능으로 런큐를 관리한다.
- 하드 디스크 등의 저장소 읽기 처리를 기다리고 있는 I/O 요구 행렬
  - 데이터베이스의 디스크 I/O
- 네트워크 접속 성립을 기다리고 있는 접속 요구 행렬

---

# 배타적 제어

