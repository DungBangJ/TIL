# void형 함수

## 내가 알던 void형 함수

내가 알던 void형 함수는 그저 리턴값이 없는 함수였다. 딱 거기까지만 생각을 했다.

이제까지 C 문제를 풀면서 void형 함수를 사용했던 적이 많지는 않았다. 지금은 딱 두 가지 경우가 기억에 남는다. 

1. swap 함수 구현
2. write 함수를 사용하기 위한 함수

이 두 경우를 제외하고 사용한 기억이 거의 없다. 그래서 void형 함수의 기능에 크게 관심을 두지 않았지만, git에서 코드를 열람하던 중에 C 초보인 나에게 매우 이상한 코드가 눈에 들어왔다.

## 다시 알게된 void형 함수

다음의 코드를 보자.

```c
void    ft_increment(int arr[], int size, int i)
{
    int c;

    c = i + 1;
    arr[i]++;
    while (c <= size)
    {
        arr[c] = arr[c - 1] + 1;
        c++;
    }
}
```

위 코드는 arr 배열을 받아와서 그 배열의 값을 변형하는 코드이다. 처음에 이 코드를 보고 단순하게 void형이니까 쓸모없는 함수인데 왜 배열의 값을 변경시키고 있을까하는 생각이 들었다.

계속 생각을 하다가, 이해가 잘 가지 않아서 모든 코드에서 저 함수만 주석 처리를하고 다시 돌려봤다. 역시 저 함수가 없으면 배열의 값이 변경되지 않았다.

순간 등골이 서늘했다. 내가 이제까지 void형 함수를 사용했던 경우를 떠올려보면, write함수를 따로 빼서 쓰기 위한 경우는 별로 와닿지 않았지만, 다음과 같이 swap 함수를 구현할 때를 떠올려보니 아차싶었다.

```c
void ft_swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}
```

항상 아무 생각 없이 함수를 구현하고 있었던 것이다. 위의 swap 함수에서 a와 b가 의미하는 것은 인자의 주소이다. 그리고 함수 구현부 안의 *a와 *b는 그 주소에 있는 값을 의미한다.

### 유레카!

여기서 내가 간과한 부분이 있었다. swap 함수는 단지 함수에서 주소값을 받아와 그 주소에 해당하는 값을 변경시켜주고 리턴값 없이 끝나는 함수였다. 

## 그래서 이 개념이 왜 나에게 중요했는데?

이제까지 나는 배열의 값을 변경하고 싶을 때 다음과 같이 포인터형 함수로 매개변수로 배열의 주소를 받아와서 새로운 배열을 반환하는 방식을 사용해왔고, 무조건 그 방식만 있는 줄 알고 있었다.

```c
int    *ft_increment(int arr[], int size, int i)
{
    int c;

    c = i + 1;
    arr[i]++;
    while (c <= size)
    {
        arr[c] = arr[c - 1] + 1;
        c++;
    }
    return (arr);
}
```

위와 같은 코드가 되면 항상 저 함수를 호출하는 함수에서 새로운 배열을 선언하고 위의 함수를 이용해서 그 새로운 배열을 초긱화 해줘야한다. (매우 복잡한 방식이었고, 나에게는 까다로웠다.)

하지만 이제는 void형 함수를 이용해서 단순하게 함수 호출만으로도 원하는 배열의 값을 변경할 수 있다는 것을 알게 되었다.

나이스~