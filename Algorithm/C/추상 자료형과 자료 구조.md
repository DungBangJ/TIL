- [자료형 (Data Type)](#자료형-data-type)
- [추상화 (Abstraction)](#추상화-abstraction)
- [추상 자료형 (ADT, Abstraction Data Type)](#추상-자료형-adt-abstraction-data-type)
  - [추상 자료형의 예](#추상-자료형의-예)
- [자료 구조 (Data Structure)](#자료-구조-data-structure)
  - [분류](#분류)
- [배열 (Array)](#배열-array)
  - [배열의 장점](#배열의-장점)
  - [배열의 한계](#배열의-한계)
- [리스트 (list)](#리스트-list)
  - [리스트의 기능](#리스트의-기능)
- [연결 리스트 (Linked list)](#연결-리스트-linked-list)
- [스택](#스택)
- [큐](#큐)
- [트리](#트리)
  - [이진 트리 (binary tree)](#이진-트리-binary-tree)
  - [이진 탐색 트리 (BST, Binary Search Tree)](#이진-탐색-트리-bst-binary-search-tree)
- [힙(우선순위 큐)](#힙우선순위-큐)
- [해시 테이블(hash table)](#해시-테이블hash-table)
- [딕셔너리와 심볼 테이블](#딕셔너리와-심볼-테이블)
- [그래프(graph)](#그래프graph)
  - [깊이 우선 탐색(DFS, Depth First Search)](#깊이-우선-탐색dfs-depth-first-search)
  - [백트래킹(Back Tracking)](#백트래킹back-tracking)
  - [너비 우선 탐색(BFS, Breadth Fisrt Search)](#너비-우선-탐색bfs-breadth-fisrt-search)
- [정렬](#정렬)

---

# 자료형 (Data Type)

저장되는 데이터의 종류에 따른 형태로, 저장되는 값의 종류와 범위에 따라 다르게 표현 된다.

---

# 추상화 (Abstraction)

**핵심 개념이나 기능을 간추려 내는 것**

- 크고 복잡한 상황을 더 잘 관리하도록 하는 것
- 자료구조에서 추상화는 세부 구현으로 부터 분리하여 개념을 일반화 시키는 것을 의미
  - 데이터 모델링
  - **무엇(what)** 인지는 정의하지만, **어떻게(how)** 구현할 것인지는 정의하지 않음

---

# 추상 자료형 (ADT, Abstraction Data Type)

세부 구현으로부터 분리해 **핵심 개념**이나 **기능**을 간추려 낸 자료형

- 구현 내용은 명시하지 않고 **인터페이스만 제공**
- 구현으로부터 분리하고 간단한 인터페이스만 제공
  - 추상화를 통해 **캡슐화 가능**
    - 캡슐화를 통해 정보 은닉 가능
- 결론적으로, 구현자와 사용자를 분리해준다.

## 추상 자료형의 예

- 리스트
- 스택
- 큐
- 맵

![](img/2022-05-17-18-11-28.png)

---

# 자료 구조 (Data Structure)

자료(Data)의 집합

- 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것
- 목적
  - 자료를 효율적으로 저장 및 관리
    - 잘 선택된 자료구조는 실행시간을 단축시키거나 메모리를 절약

## 분류

선형 구조

- 배열
- 연결 리스트
- 스택
- 큐

비선형 구조

- 트리
- 그래프

---

# 배열 (Array)

같은 자료형의 다중 원소 집합

- 연관된 데이터를 하나의 변수에 그룹핑해서 관리한다.

## 배열의 장점

index를 통해서 빠르게 데이터를 가져올 수 있다.

- index를 이용한 조회
  - index의 값이 고정되어 있어야만 한다.

## 배열의 한계

배열의 크기보다 더 많은 양을 저장할 수 없다.

- 새로운 배열을 생성해줘야 한다.

배열의 요소를 삭제하면 중간의 빈 공간은 메꿔지지 않는다.

- 빈틈없이 연속적으로 위치하게 하는 스트럭처를 리스트(list)라고 한다.
  - 하지만 이 스트럭처는 빈 공간을 메꾸면서 index까지 바꿔버린다.
    - 예를 들어, index 3 자리를 메꾸기 위해 index 4부터 당겨버리면 모든 index들이 -1씩 영향을 받게 되는 것이다.

---

# 리스트 (list)

리스트는 배열이 가지고 있는 index라는 장점을버리고 대신 **빈틈없는 데이터의 적재**라는 장점을 취한 Data Structure다.

- 순서가 있는 element의 모임

## 리스트의 기능

- 빈 element는 불허
- 중복 데이터 허용
  - set과의 차이
- 처음, 끝, 중간에 element를 추가/삭제 가능

---

# 연결 리스트 (Linked list)

배열과는 다르게 노드들의 위치가 흩어져 있기 때문에 연결되어 있는 구조이다.

- 노드는 최소한 두 가지 정보를 갖고 있어야 한다.
  - 현재 노드의 값
  - 다음 노드의 주소

![](img/2022-05-17-18-50-52.png)

- Head
  - 첫번째 노드

연결 리스트는 원소에 직접 접근할 수 없기 때문에 조회에 있어서는 배열보다 속도가 많이 느리다. 하지만 저장할 원소의 개수를 미리 알지 못할 때 배열보다 유용하다.

---

# 스택

후입선출 (LIFO, Last In First Out)

- 마지막에 추가된 원소가 먼저 제거된다.

스택의 예

- 재귀(recursion) 호출
- 후위 표현식(postfix expression)의 계산
- 스택으로 구현하는 백 트래킹
- 트리와 그래프의 깊이 우선 탐색(DFS, Depth-First Search)
- 10진수를 2진수로 변환하기

스택의 모든 연산의 시간 복잡도

- O(1)

---

# 큐

선입선출 (FIFO, First In First Out)

- 먼저 추가한 원소가 먼저 제거된다.

큐의 예

- 공유 자원 접근(예: 프린터)
- 멀티 프로그래밍
- 그래프와 트리의 너비 우선 탐색(BFS, Breadth First Search)

큐의 모든 연산의 시간 복잡도

- O(1)

---

# 트리

계층형 자료 구조

트리의 최상위 원소

- 루트

## 이진 트리 (binary tree)

각 노드는 2개 이하의 자식 노드를 갖고 있다.

## 이진 탐색 트리 (BST, Binary Search Tree)

- 왼쪽 하위 트리의 키가 부모 노드의 키보다 작거나 같다.
- 오른쪽 하위 트리의 키가 부모 노드의 키보다 크거나 같다.
- 이진 탐색 트리의 시간 복잡도
  - 트리가 균형을 이룰 때 평균적인 시간 복잡도
    - O(logn)
    - 항상 균형을 이루는 이진 탐색 트리
      - AVL 트리
        - 모든 노드에 대해서 왼쪽 트리와 오른쪽 트리의 높이 차가 1이하인 BST
      - RB 트리
        - 노드의 색이 red or black
        - root 노드의 색은 무조건 black
        - 모든 leaf 노드의 색은 무조건 black
        - red 노드의 자식 노드의 색은 무조건 black이지만, black 노드의 자식 노드의 색은 red or black이다.
        - 각 노드에서 그 노드에서 갈 수 있는 leaf 노드까지의 경로에 있는 black 노드의 수는 모두 같아야 한다.
  - 트리가 균형을 이루지 못할 때 최악의 시간 복잡도
    - O(n)

---

# 힙(우선순위 큐)

우선순위 큐(priority queue)

- 우선순위에 따라 특별한 순서로 원소를 추출하는 특별한 종류의 큐
- 이진 힙 자료구조로 구현

레코드

- 배열에 저장

모든 노드느 부모의 갑이 자식 값보다 크다는(또는 작다는) 통일된 규칙을 따른다.

힙 자료 구조의 두 가지 유형

- 최대 힙(Max heap)
  - 각 노드의 값은 자식 노드의 값 이상
- 최소 힙(Min heap)
  - 각 노드의 값은 자식 노드의 값 이하

---

# 해시 테이블(hash table)

- 키에 값을 매핑하는 자료 구조
- 해시 테이블의 각 위치는 슬롯(slot)
- 해시 함수로 배열의 인덱스를 계산
- 해시 테이블은 딕셔너리를 구현하는 데 유용한 자료 구조
- 해시 테이블에서 원소를 찾는 데 걸리는 평균 O(1)

---

# 딕셔너리와 심볼 테이블

심볼 테이블(symbol table)

- 문자열인 키와 어떤 데이터 유형이든 가능한 값과의 매핑
  - 1대1 매칭 시켜주는 것
  - 딕셔너리가 심볼 테이블의 중요한 예
    - 단어 = 키
    - 단어의 의미 = 데이터

---

# 그래프(graph)

- 네트워크를 표현하는 자료 구조
- 정점(vertex)이라 부르는 노드와 정점 사이를 연결하는 간선(edge)의 집합으로 구성된다.
- 간선은 두 정점 간의 경로(path)
- 경로는 단방향, 양방향 모두 가능
- 간선에 비용이 발생할 수 있다.

## 깊이 우선 탐색(DFS, Depth First Search)

- 한 정점에서 시작해 해당 분기를 모두 탐색하고 다음 분기로 넘어가면서 모든 정점을 탐색
- 너비 우선 탐색보다 간단하지만 속도가 느릴 수 있다.
  - 모든 정점을 한 번씩 탐색해야하므로 불필요한 탐색이 발생한다.
- 재귀함수나 스택으로 구현

## 백트래킹(Back Tracking)

- DFS에서의 불필요한 탐색을 없앨 수 있다.
  - 어떠한 분기를 탐색하던 도중에 절대로 답이 될 수 없는 분기라고 판단되면 부모 노드로 돌아가게 한다.

## 너비 우선 탐색(BFS, Breadth Fisrt Search)

- 한 정점에 인접한 정점들을 우선적으로 모두 탐색한다.
- 재귀적으로 동작하지 않으며, 방문 상태를 반드시 확인해줘야 한다.
- 큐 자료구조로 구현한다.
  - 루트 노드를 큐에 삽입하고 큐에 삽입한 모든 노드들의 방문 상태를 체크해준다.
  - 큐에 있는 노드를 차례로 dequeue하면서 그 노드에 인접하고 방문하지 않은 모든 노드들을 enqueue하고 방문상태를 체크한다.
  - 위의 과정을 반복한다.

---

# 정렬

- 컬렉션에서 원소를 오름차순 또는 내림차순으로 배치하는 과정
