- [주소 종류](#주소-종류)
  - [논리적 주소(logical address), 가상 주소(virtual address)](#논리적-주소logical-address-가상-주소virtual-address)
  - [물리적 주소(physical address)](#물리적-주소physical-address)
- [주소 바인딩(address binding)](#주소-바인딩address-binding)
  - [컴파일 타임 바인딩(compile time binding)](#컴파일-타임-바인딩compile-time-binding)
  - [로드 타임 바인딩(load time binding)](#로드-타임-바인딩load-time-binding)
  - [실행시간 바인딩(execution time binding 또는 run time binding)](#실행시간-바인딩execution-time-binding-또는-run-time-binding)
    - [MMU 기법](#mmu-기법)
- [메모리 관리와 관련된 용어](#메모리-관리와-관련된-용어)
  - [동적로딩](#동적로딩)
  - [동적연결](#동적연결)
  - [중첩(overlays)](#중첩overlays)
  - [스와핑(swapping)](#스와핑swapping)
- [물리적 메모리의 할당 방식](#물리적-메모리의-할당-방식)
  - [연속할당 방식(contiguous allocation)](#연속할당-방식contiguous-allocation)
    - [고정분할 방식(fixed partition allocation)](#고정분할-방식fixed-partition-allocation)
    - [가변분할 방식(variable partition allocation)](#가변분할-방식variable-partition-allocation)
  - [불연속할당 기법(noncontiguous allocation)](#불연속할당-기법noncontiguous-allocation)
    - [페이징 기법(paging)](#페이징-기법paging)
      - [주소 변환 기법(address translation)](#주소-변환-기법address-translation)
      - [페이지 테이블](#페이지-테이블)
      - [TLB(Translation Look-aside Buffer)](#tlbtranslation-look-aside-buffer)
      - [계층적 페이징(2단계 페이징)](#계층적-페이징2단계-페이징)
      - [역페이지 테이블](#역페이지-테이블)
      - [공유 페이지](#공유-페이지)
      - [메모리 보호](#메모리-보호)
- [세그먼테이션](#세그먼테이션)
  - [세그먼트 테이블](#세그먼트-테이블)
- [페이지드 세그먼테이션(paged segmentation)](#페이지드-세그먼테이션paged-segmentation)

---

우리가 사용하는 컴퓨터 시스템은 32비트 혹은 64비트의 주소 체계를 사용

- 32비트의 주소 체계를 사용할 경우 2^32가지의 서로 다른 메모리 위치를 구분
  - 컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트 주소 체계를 사용하면 2^32 바이트만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.

컴퓨터상의 주소는 효율적인 운영을 위해 보통 4KB(= 2^12byte) 단위로 묶어서 페이지(page)라는 하나의 행정구역을 만든다.

- 페이지 하나의 크기 2^12바이트
  - 페이지 내에서 위치 구분을 위해서 12비트가 필요

---

# 주소 종류

## 논리적 주소(logical address), 가상 주소(virtual address)

- 메모리에 적재되었을 때 그 프로세스를 위한 독자적인 주소 공간
- 각 프로세스마다 독립적으로 할당
- 0번지부터 시작

## 물리적 주소(physical address)

- 물리적 메모리에 실제로 올라가는 위치
- 영역
  - 낮은 주소 영역
    - 운영체제
  - 높은 주소 영역
    - 사용자 프로세스

---

# 주소 바인딩(address binding)

***프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩이라고 한다.***

- 물리적 메모리의 주소가 결정되는 시기에 따라 세가지로 분류

## 컴파일 타임 바인딩(compile time binding)

- 물리적 메모리 주소가 프로그램을 컴파일할 때 결정
- 절대코드(absolute code)
  - 프로그램이 절대주소로 적재된다.
- 물리적 메모리 위치를 변경하고 싶을 때는 컴파일을 다시 해야한다.
  - 시분할 컴퓨팅 환경에서는 잘 쓰이지 않는다.

## 로드 타임 바인딩(load time binding)

- 프로그램이 시작될 때 물리적 메모리 주소 결정
- 로더(loader)
  - 사용자 프로그램을 메모리에 적재시키는 프로그램
  - 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정된다.

## 실행시간 바인딩(execution time binding 또는 run time binding)

- 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있다.
- CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블을 이용해 바인딩을 점검
- 기준 레지스터와 한계 레지스터
- MMU(Memory Management Unit: 메모리 관리 유닛)
  - 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치

### MMU 기법

- CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때
  - 논리적 주소 + 기준 레지스터의 값 => 물리적 주소값
    - 논리적 주소 = offset
    - 기준 레스스터 = 재배치 레지스터
      - 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.
- 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정
  - 그 프로그램이 적재되는 물리적 메모리상의 시작 주소만 알면 주소 변환을 쉽게 할 수 있다.
- 사용자 프로그램이나 CPU는 논리적 주소만을 다룬다.
  - 실제 물리적 주소는 알 필요가 없다.
- CPU가 요청한 논리적 주소값과 재배치 레스터 안에 있는 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나는 경우
  - 메모리 보안 미성립, 운영체제 영역 침범 우려
  - 운영체제의 방책
    - 한계 레지스터 사용
      - 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는 것을 감시
      - 프로세스의 크기를 담고 있다.
        - 현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값
  - 메모리 보안 유지
    - 한계 레지스터를 넘지 않는지 확인

---

# 메모리 관리와 관련된 용어

## 동적로딩

프로세스 내에서 실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재하는 것

## 동적연결

연결(linking)

- 소스 코드를 컴파일하여 생성된 목적 파일, 이미 컴파일된 라이브러리 파일을 묶은 하나의 실행파일을 생성하는 과정
- 동적연결
  - 연결을 프로그램의 실행 시점까지 지연시키는 기법
  - 실행파일에 라이브러리 코드가 포함되지 않는다.
  - 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다.
  - 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한 스텁(stub)이라는 작은 코드를 둔다.
    - 라이브러리 호출 시 스텁을 통해 해당 라이브러리가 메모리에 이미 존재하는지 확인
      - 없을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재 후 수행
  - 동적연결에서는 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재
    - 운영체제 지원 필요

## 중첩(overlays)

프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재

- 동적로딩과의 차이
  - 중첩은 필요한 부분을 올리고 나중에 나머지 부분을 올려서 실행하는 기법
    - 메모리 용량이 작아서 어쩔 수 없는 것
  - 동적로딩은 필요한 부분이 있나면 언제나 올려서 쓸 수 있다.
- 운영체제 지원 필요없이 프로그래머에 의해 구현

## 스와핑(swapping)

메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것

- 백킹스토어(backing store)
- 파일시스템과는 별도의 영역
- 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간
- 특정한 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것
- 과정
  - 스와퍼(swapper) = 중기 스케쥴러(medium-term scheduler)
    - 스왑시킬 프로세스를 선정
    - 선정된 프로세스의 현재 메모리에 올라가 있는 주소 공간의 내용 전체를 디스크 스왑 영역에 스왑 아웃시킨다.
- 역할
  - 메모리에 존재하는 프로세스의 수 조절
  - 메모리에서 프로그램이 충분히 실행되고 나면, 스왑 아웃되었던 프로그램을 스왑 인 시킨다.
- 컴파일 타임 바인딩, 로드 타임 바인딩
  - 프로세스가 스왑 인될 때 원래 존재하던 메모리 위치로 다시 올라가야 한다.
- 실행시간 바인딩
  - 빈 메모리 여역 아무 곳에나 스왑 인
- 디스크 탐색시간(seek time), 회전지연시간(rotational latenct)보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송 시간(transfer time)이 대부분을 차지

---

# 물리적 메모리의 할당 방식

물리적 메모리

- 운영체제 상주영역
  - 인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역
  - 운영체제 커널이 이곳에 위치
- 사용자 프로세스 영역
  - 물리적 메모리의 높은 주소 영역
  - 관리 방법
    - 연속할당
      - 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식
      - 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스 적재
        - 고정분할
          - 물리적 메모리를 고정된 크기로 분할
        - 가변분할
          - 분할을 미리 나눠놓지 않고 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리
    - 불연속할당
      - 하나의 프로세스를 물리적 메모리의 여러 영역에 분산 적재
        - 페이징(paging) 기법
          - 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재
        - 세크먼테이션(segmentation) 기법
          - 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재

## 연속할당 방식(contiguous allocation)

프로세스를 물리적 메모리의 한 곳에 연속적으로 적재하는 방식

### 고정분할 방식(fixed partition allocation)

물리적 메모리를 주어진 개수만큼의 영구적인 분할(partition)로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행

- 분할 크기는 같게 할 수도 있고, 다르게 할 수도 있다.
  - 두 방식 모두 하나의 프로세스만 적재가능
- 외부 조각, 내부 조각 발생 가능
  - 메모리 낭비

### 가변분할 방식(variable partition allocation)

메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식

- 내부조각 발생X, 외부조각 발생 가능
  - 메모리에 존재하던 프로그램이 종료되고, 다음 프로그램이 들어 올 경우 외부조각 발생 가능
- 메모리 내 가용공간 중 어떤 위치에 올릴 것인가?
  - 동적 메모리 할당 문제(dynamic storage-allocation problem)
  - 운영체제는 가용, 비가용 메모리 공간의 정보를 파악하고 있다.
  - 메모리 할당 문제 해결 방법
    - 최초적합 방법(first-fit)
      - 크기가 n이상인 가용 공간 중 가장 먼저 찾아지는 곳에 할당
      - 시간적인 측면에서 효율적
    - 최적적합 방법(best-fit)
      - 크기가 n이상인 가장 작은 가용 공간을 찾아 할당
      - 리스트가 크기순으로 정렬되어 있지 않으면 모든 가용 공간 리스트를 탐색해야 한다.
        - 시간적 오버헤드 발생
      - 공간적 측면에서 효율적
    - 최악적합(worst-fit)
      - 가용 공간 중에서 가장 큰 곳에 할당
      - 가용 공간 빨리 소진
- 컴팩션(compaction)
  - 외부조각 문제 해결
  - 가용 공간, 비가용 공간을 한쪽으로 몰기
  - 과다 비용
  - 실행시간 바인딩 방식에서만 수행 가능

## 불연속할당 기법(noncontiguous allocation)

하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법

- 페이징 기법(paging)
  - 동일한 크기로 나눔
- 세그먼테이션 기법(segmentation)
  - 크기는 일정하지 않지만 의미 단위로 나눔
- 페이징 세그먼테이션(paging segmentation)
  - 세그먼테이션을 기본으로 하고 이를 다시 동일 크기의 페이지로 나눔

### 페이징 기법(paging)

프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장

- 각 프로세스의 주소 공간 일부는 백킹 스토어, 일부는 물리적 메모리에 혼재 가능
- 물리적 메모리를 페이지와 동일한 크기의 프레임(frame)으로 미리 나눔
  - 메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로, 메모리를 같은 크기로 미리 분할해두더라도 빈 프레임이 있으면 어떤 위치이든 사용 가능하기 때문
    - 그래서 동적 메모리 할당 문제 일어나지 않음
      - 외부조각에 의한 메모리 낭비 X
- 주소 변환 절차 복잡
  - 페이지 단위로 물리적 메모리에 올리는 위치가 상이하기 때문
  - 특정 프로세스의 모든 페이지가 물리적 메모리의 몇 번째 프레임에 있는지 페이지별 주소 변환 정보를 유지해야 한다.
    - 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블(page table)을 가진다.
      - 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다.
- 프로세스의 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위
  - 빈 공간을 어느 곳이든 활용 가능
  - 내부조각은 발생 가능

#### 주소 변환 기법(address translation)

CPU가 사용하는 논리적 주소

- 페이지 번호(p), 페이지 오프셋(d)으로 나눔
  - 주소 변환에 사용한다.
- 페이지 번호(p)
  - 인덱스(index)
    - 인덱스 항목(entry)
      - 페이지의 물리적 메모리의 기준 주소(base address)
        - 시작 위치
  - 특정 프로세스의 페이지 테이블에서 p번째 항목
    - 해당 프로세스의 p번째 페이지가 위치한 물리적 메모리의 시작 위치
- 페이지 오프셋(d)
  - 페이지 내에서의 변위(displacement)
    - 기준 주소값 + 오프셋 = 물리적 주소

#### 페이지 테이블

- 페이징 기법에서 주소 변환을 하기 위한 자료구조
- 물리적 메모리에 위치
- 현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용한다.
  - 페이지 테이블 기준 레지스터(page-table base register)
    - 메모리 내에서의 페이지 테이블의 시작 위치
  - 페이지 테이블 길이 레지스터(page-table length register)
    - 페이지 테이블의 크기를 보관
- 모든 페이지에 대한 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어있다.
  - 페이지 번호가 주어짐
    - 테이블의 시작 위치에서 페이지 번호만큼 떨어진 항목(entry)에 곧바로 접근
      - 해당 페이지에 대응되는 물리적 메모리의 프레임 번호를 얻는다.

#### TLB(Translation Look-aside Buffer)

- 페이징 기법에서는 두번의 메모리 접근이 필요하다.
  - 주소 변환을 위해 페이지 테이블에 접근
  - 변환된 주소에서 실제 데이터에 접근
- 접근 오버헤드 줄이기 위해 TLB 사용
- 고속의 주소 변환용 하드웨어 캐시
- 메모리에 비싸다.
  - 모든 정보를 담을 수 없다.
  - 자주 참조되는 페이지에 대한 주소 정보만 저장
    - TLB에 존재하면 곧바로 대응하는 물리적 메모리의 프레임 번호 획득 가능
- 모든 페이지에 대한 주소 변환 정보를 TLB가 가지고 있지 않음
  - 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어야 한다.
- 해당 페이지에 대한 주소 변환 정보가 TLB에 있는지 TLB의 모든 항목(entry)을 다 찾아봐야 한다.
  - 오버헤드 발생
    - 연관 레지스터(associative register) 사용
      - 병렬탐색(parallel search) 가능
        - TLB 내의 모든 항복을 한꺼번에 조사

#### 계층적 페이징(2단계 페이징)

페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 2단계 페이징기법(two-level paging)을 사용

- 외부 페이지 테이블(outer-page table), 내부 페이지 테이블(inner-page table)
  - 사용되지 않는 주소 공간에 대해서는 외부 페이지 테이블의 항목을 NULL로 설정
    - 여기에 대응하는 내부 페이지 테이블을 생성하지 않는다.
  - 이 과정을 통해 1단계 페이징 기법에 비해서 메모리의 낭비를 크게 줄임
  - 주소 변환을 위해 접근해야 하는 페이지 테이블의 수가 증가
    - 시간적인 손해
- 프로세스의 논리적 주소를 두 종류의 페이지 번호(P1, P2)와 오프셋(d)으로 구분
  - 첫 번째 페이지 번호 P1
    - 외부 페이지 테이블의 인덱스
  - 두 번째 페이지 번호 P2
    - 내부 페이지 테이블의 인덱스
- 프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커진다.
  - 주소 변환을 위한 메모리 공간 낭비 역시 더 심각해지게 된다.
    - 더 큰 다단계 페이지 테이블이 필요하게 된다.
      - 메모리 공간의 소모는 줄일 수 있지만 그만큼 메모리에 대한 접근 횟수가 많아진다.
        - 메모리 접근시간이 크게 늘어나는 문제점 발생
        - 이러한 메모리 접근에 의한 시간적인 오버헤드를 줄이기 위해서는 TLB가 효과적
        - TLB를 함께 사용하면
          - 다단계 페이지 테이블로 인한 공간적인 이득
          - 메모리 접근시간도 많이 늘어나지 않아 시간적 효율성 이득

#### 역페이지 테이블

물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식

- 논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라, 물리적 주소에 대해 페이지 테이블을 만드는 것
- 각 프로세스마다 페이지 테이블을 두지 않고, 시스템 전체에 페이지 테이블을 하나만 두는 방법
- 항목
  - 어느 프로세스의 어느 페이지가 이 프레임에 저장되었는지의 정보를 보관
  - 즉 페이지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(p)를 담고 있게 된다.
- 주소변환이 비효율적
  - 역페이지 테이블에 주소 변환 요청
    - 그 주소를 담은 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해 페이지 테이블 전체를 다 탐색해야 한다.
      - 시간적 손해
        - 그래서 역페이지 테이블은 일반적으로 메모리에 유지하는 대신 연관 레지스터에 보관
        - 전체 항목에 대한 병렬탐색 가능

#### 공유 페이지

공유 코드를 담고 있는 페이지

- 공유 코드(shared code)
  - 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드
  - 재진입 가능 코드(re-entrant code), 순수 코드(pure code)
  - 읽기 전용(read only)
- 물리적 메모리에 하나만 적재
- 공유 페이지는 그 페이지를 공유하는 모든 프로세스의 주소 공간에서 동일한 페이지 번호를 가져야 한다.
- 공유 페이지의 반대 사유 페이지

#### 메모리 보호

페이지 테이블의 각 항목에는 메모리 보호를 위한 보호비트와 유요-무효 비트가 있다.

- 보호비트(protection bit)
  - 각 페이지에 대한 접근 권한
    - 읽기-쓰기/읽기 전용 등의 접근 권한 설정하는 데에 사용
- 유효-무효 비트(valid-invalid bit)
  - 유효
    - 해당 메모리 프레임에 그 페이지가 존재
    - 접근 허용
  - 무효
    - 프로세스가 그 주소 부분을 사용하지 않음
    - 해당 페이지가 물리적 메모리에 없고 백킹 스토어에 있음
    - 접근 불가

---

# 세그먼테이션

프로세스의 주소 공간을 의미 단위(코드, 데이터, 스택)의 세크먼트(segment)로 나누어 물리적 메모리에 적재

- 논리적인 단위(logical unit)
  - 크기 불균일
- 주소 공간 나눠서 적재
  - 크기 불균일해서 관리하는데 오버헤드 발생
- <세그먼트 번호, 오프셋>
- 주소 변환시 확인사항
  - 세그먼트 번호가 STLR값보다 작은지
    - 그렇지 않다면 이는 존재하지 않는 세그먼트에 대한 접근 시도
  - 논리적 주소의 오프셋값이 그 세그먼트의 길이보다 작은지
    - 한계점을 넘어서면 안된다.
- 공유 세그먼트(shared segment)
  - 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치
- 공유와 보안의 측면에서 페이징 기법보다 좋다.
- 세그먼트 길이 불균일
  - 외부조각 발생
  - 최초적합 방식
  - 최적적합 방식

## 세그먼트 테이블

- 주소 변환
- 항목
  - 기준점(base)
    - 물리적 메모리에서 그 세그먼트의 시작 위치
  - 한계점(limit)
    - 그 세그먼트의 길이
      - 세그먼트 길이가 불균일해서 위치 정보뿐 아니라 길이 정보도 보관
- 레지스터
  - 세그먼트 테이블 기준 레지스터(Segment-Table Base Register: STBR)
    - 세그먼트 테이블의 메모리 상 위치
  - 세그먼트 테이블 길이 레지스터(Segment-Table Length Register: STLR)
    - 세그먼트의 개수
- 각 항목에 비트를 둔다.
  - 보호비트
    - 각 세그먼트에 대해 읽기/쓰기/실행 등의 권한 확인
  - 유효비트
    - 해당 세그먼트가 현재 물리적 메모리에 적재되어 있는지 확인

---

# 페이지드 세그먼테이션(paged segmentation)

페이징 기법과 세그먼테이션 기법의 장점만을 취함

- 의미 단위의 세그먼트로 나눈다.
  - 단 반드시 동일한 크기 페이지들의 집합으로 구성
- 물리적 메모리에 적재하는 단위는 페이지 단위
- 장점
  - 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부조각의 문제점을 해결
  - 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함
- <세그먼트 번호, 오프셋> 논리적 주소
  - 물리적 주소로 변환하는 과정
    - 논리적 주소의 상위 비트인 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목에 접근
      - 이 항목에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작 주소가 들어있다.
    - 오프셋값을 상위, 하위 비트로 나눈다.
      - 상위 비트는 그 세그먼트 내에서의 페이지 번호로 사용
      - 하위 비트는 페이지 내에서의 변위로 사용
    - 물리적 메모리의 페이지 프레임 위치를 알아낸다.
      - 이 위치에서 오프셋의 하위 비트값인 페이지 내 변위만큼 떨어진 곳이 바로 원하는 물리적 메모리 주소
