- [요구 페이징](#요구-페이징)
  - [요구 페이징의 페이지 부재 처리](#요구-페이징의-페이지-부재-처리)
  - [요구 페이징의 성능](#요구-페이징의-성능)
- [페이지 교체(page replacement)](#페이지-교체page-replacement)
  - [최적 페이지 교체](#최적-페이지-교체)
  - [선입선출 알고리즘(First In First Out: FIFO)](#선입선출-알고리즘first-in-first-out-fifo)
  - [LRU(Least Recently Used) 알고리즘](#lruleast-recently-used-알고리즘)
  - [LFU(Least Frequently Used) 알고리즘](#lfuleast-frequently-used-알고리즘)
  - [클럭 알고리즘](#클럭-알고리즘)
- [페이지 프레임의 할당](#페이지-프레임의-할당)
- [전역교체와 지역교체](#전역교체와-지역교체)
- [스레싱(thrashing)](#스레싱thrashing)
  - [워킹셋 알고리즘(working-set)](#워킹셋-알고리즘working-set)
  - [페이지 부재 빈도 알고리즘(Page Fault Frequency: PFF)](#페이지-부재-빈도-알고리즘page-fault-frequency-pff)

---

가상메모리

- 프로세스마다 각각 0번지부터의 주소 공간을 가지게 되며, 이들 공간 중 일부는 물리적 메모리에 적재되고 일부는 디스크의 스왑 영역에 존재하게 된다.
- 프로세스의 주소 공간을 메모리로 적재하는 단위에 따라 두 가지 방식
  - 요구 페이징(demand paging) 방식
  - 요구 세그먼테이션(demand segmentation) 방식
    - 페이지드 세그먼테이션을 사용하는 경우

---

# 요구 페이징

- **당장 사용될 페이지만**을 메모리에 적재
  - 메모리 사용량 감소
  - 프로세스 전체를 메모리에 올리는 데 소요되는 입출력 오버헤드 감소
- 응답시간 단축
- 페이지에 메모리가 존재하는지 확인
  - 유효-무효 비트
    - 페이지 테이블의 각 항목별로 저장
    - 무효 값으로 초기화
    - 특정 페이지가 참조되어 메모리에 적재되는 경우 유효
    - 스왑 아웃되면 무효
- 페이지 부재(page fault)
  - ***CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아 유효-무효 비트가 무효로 세팅되어 있는 경우***

## 요구 페이징의 페이지 부재 처리

CPU가 무효 페이지에 접근

- MMU가 페이지 부재 트랩(page fault trap)을 발생
  - CPU 제어권이 커널모드로 전환
  - 운영체제의 페이지 부재 처리루틴(page fault handler) 호출
- 운영체제는 해당 페이지에 대한 접근이 적법한지를 먼저 체크
  - 사용되지 않는 주소 영역에 속한 페이지에 접근 or 접근 권한 위반(protection violation)
    - 해당 프로세스 종료
- 접근이 적법하면 빈 프레임(free frame)을 할당
  - *요청된 페이지를 디스크로부터 메모리로 적재하는데 오랜 시간 소요*
    - 페이지 부재를 발생시킨 프로세스는 CPU를 빼앗기고 *봉쇄상태*
    - CPU 레지스터 상태 및 PC값을 PCB에 저장해둔다.
- 빈 프레임이 없으면 메모리상의 페이지 중 하나를 스왑 아웃

## 요구 페이징의 성능

**페이지 부재의 발생 빈도**

- 가장 큰 영향
- 페이지 부재가 일어나면 디스크로부터 메모리로 읽어오는 막대한 오버헤드 발생

---

# 페이지 교체(page replacement)

스왑 인을 하는데 메모리에 자리가 없다면 페이지 중 하나를 디스크로 쫓아내 메모리에 빈 공간을 확보하는 작업이 필요하다.

- 교체 알고리즘(replacement algorithm)
  - 페이지 교체시에 **어떤 프레임에 있는 페이지를 쫓아낼 것인지 결정**
  - 목표
    - ***페이지 부재율 최소화***

## 최적 페이지 교체

- 메모리에 존재하는 페이지 중 *가장 먼 미래*에 참조될 페이지를 쫓아냄
- 빌레디의 최적 알고리즘
- *오프라인 알고리즘*
  - **미래에 어떤 페이지가 어떤 순서로 참조될지 미리 알고 있다는 전제하에** 알고리즘을 운영

## 선입선출 알고리즘(First In First Out: FIFO)

페이지 교체 시 **물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 쫓아냄**

- 페이지의 향후 참조 가능성 고려 X

## LRU(Least Recently Used) 알고리즘

페이지 교체 시 **가장 오래전에 참조된 페이지 쫓아냄**

- *마지막 참조 시점*이 가장 오래된 페이지를 교체

## LFU(Least Frequently Used) 알고리즘

페이지의 참조 횟수로 결정

- 메모리 내에 존재하는 페이지 중에서 **과거에 참조 횟수가 가장 적었던 페이지를 쫓아냄**
- 최저 참조 횟수가 여려 개면 임의로 선정
- 페이지의 참조 횟수 계산 방식
  - Incache-LFU
    - 페이지가 물리적 메모리에 올라온 후부터의 참조 횟수를 카운트하는 방식
    - 페이지가 메모리에서도 **쫓겨났다가 다시 돌아온 경우 참조 횟수 1로 초기화**
  - Perfect-LFU
    - 메모리에 올라와 있는지의 여부와 상관없이 그 페이지의 **과거 총 참조 횟수를 카운트**
    - 장정
      - 페이지의 *참조 횟수를 정확히 반영*할 수 있다.
    - 단점
      - 메모리에서 쫓겨난 페이지의 *참조 기록까지 모두 보관하고 있어야 한다.*
        - 오버헤드 큼

## 클럭 알고리즘

하드웨어적인 지원을 통해 알고리즘 운영, 오버헤드 감소

- 대부분의 시스템에서 클럭 알고리즘 채택
- 교체할 페이지 선정을 위해 참조비트를 순차적으로 조사
- 참조비트
  - 각 프레임마다 하나씩 존재
  - ***그 프레임 내의 페이지가 참조될 때 하드웨어에 의해 1로 자동 세팅***
  - 클럭 알고리즘은 참조비트가 *1인 페이지는 0으로* 바꾼 후 그냥 지나가고 *0인 페이지는 교체한다.*
    - **시곗바늘이 한 바퀴 도는 동안 다시 참조되지 않은 페이지를 교체하는 것**
- 최근에 참조되지 않은 페이지를 교체하는 알고리즘

---

# 페이지 프레임의 할당

각 프로세스에 얼마만큼의 메모리 공간을 할당할 것인지 결정해야 한다.

- 할당 알고리즘(allocation algorithm) 세 가지
  - 균등할당(equal allocation)
    - 페이지 프레임을 *균일하게* 할당
  - 비례할당(proportional allocation)
    - 프로세스의 *크기에 비례해* 페이지 프레임을 할당
  - 우선순위 할당(priority allocation)
    - 프로세스의 *우선순위에 따라* 페이지 프레임을 다르게 할당

---

# 전역교체와 지역교체

교체 대상이 될 프레임의 범위를 어떻게 정할지

- 전역교체(global replacement)
  - **모든 페이지 프레임이 교체 대상**
  - 예
    - LRU 알고리즘으로 전역교체를 한다면 **물리적 메모리 전체에 올라와 있는 페이지 중** 가장 오래전에 참조된 페이지를 교체한다.
    - 즉, 페이지 교체 시 다른 프로세스에 할당된 프레임을 *빼앗아올 수 있는* 방식
- 지역교체(local replacement)
  - 수행 중인 프로세스에게 **할당된 프레임 내에서만 교체 대상을 선정**
  - 프로세스마다 페이지 프레임을 미리 할당하는 것을 전제로 한다.

---

# 스레싱(thrashing)

집중적으로 참조되는 페이지들의 집합을 메모리에 한꺼번에 적재하지 못하면 *페이지 부재율(page fault rate)이 크게 상승해* **CPU 이용률(CPU utilization)이 급격히 떨어지는 것**

- CPU 이용률 낮음
- => 운영체제는 메모리상의 프로세스 수가 적다고 판단
- => 운영체제는 메모리에 올라가는 프로세스의 수를 늘림
  - 다중 프로그래밍 정도(Multi-Programming Degree: MPD)
    - 메모리에 동시에 올라가 있는 프로세스의 수
- => 각 프로세스에게 할당되는 메모리 양이 지나치게 감소, 최소한의 페이지 프레임도 할당받지 못하는 상태가 된다.
- => 페이지 부재 발생
- => 디스크 I/O 작업 수행
- => 문맥교환으로 다른 프로세스에게 CPU이양
- => 다른 프로세스도 메모리 부족으로 페이지 부재
- => CPU 이용률 더 저하
- => MPD 더 올림, 반복, CPU는 일을 거의 하지 않게된다.
- 스레싱 발생

>MPD를 조절해 CPU 이용률을 높이는 동시에 스레싱 발생을 방지하는 방법에는 워킹셋 알고리즘과 페이지 부재 빈도 알고리즘이 있다.

## 워킹셋 알고리즘(working-set)

지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장하는 메모리 관리 알고리즘

- 지역성 집합(locality set)
  - 집중적으로 참조되는 페이지들의 집합
- 워킹셋(working-set)
  - 프로세스가 원활히 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합
- 프로세스의 워킹셋을 구성하는 페이지들이 한꺼번에 메모리에 올라갈 수 있는 경우에만 그 프로세스에게 메모리를 할당
  - 그렇지 않는다면 전체를 스왑 아웃
- 워킹셋 윈도우
  - 메모리에 올라갈 페이지들의 집합을 결정
  - 윈도우의 크기가 너무 작으면
    - 지역성 집합을 모두 수용 불가
  - 윈도우의 크기가 너무 크면
    - 여러 규모의 지역성 집합 수용 가능
      - MPD감소, CPU이용률 감소

## 페이지 부재 빈도 알고리즘(Page Fault Frequency: PFF)

프로세스의 페이지 부재율을 주기적으로 조사하고 이 값에 근거해서 각 프로세스에 할당할 메모리 양을 동적으로 조절한다.

- 부재율이
  - 상한값을 넘으면
    - 프로세스에 할당된 프레임의 수가 부족하다고 판단
    - 프로세스에게 프레임을 추가로 할당
  - 하한값 이하로 떨어지면
    - 프로세스에게 필요 이상의 많은 프레임이 할당된 것으로 판단
    - 할당된 프레임 수를 줄인다.
