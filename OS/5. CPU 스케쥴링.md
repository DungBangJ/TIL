
- [버스트](#버스트)
  - [버스트 비율](#버스트-비율)
- [스케쥴러](#스케쥴러)
- [디스패처](#디스패처)
- [스케쥴링의 성능 평가](#스케쥴링의-성능-평가)
  - [시스템 관점의 지표](#시스템-관점의-지표)
  - [사용자 관점의 지표](#사용자-관점의-지표)
- [스케쥴링 알고리즘](#스케쥴링-알고리즘)
  - [선입선출 스케쥴링(First-Com First-Served: FCFS)](#선입선출-스케쥴링first-com-first-served-fcfs)
  - [최단작업 우선 스케쥴링(Shortest-Job first: SJF)](#최단작업-우선-스케쥴링shortest-job-first-sjf)
  - [우선순위 스케쥴링(priority scheduling)](#우선순위-스케쥴링priority-scheduling)
  - [라운드 로빈 스케쥴링(Round Robin Scheduling)](#라운드-로빈-스케쥴링round-robin-scheduling)
  - [멀티레벨 큐(multi-level queue)](#멀티레벨-큐multi-level-queue)
  - [멀티레벨 피드백 큐(Multilevel Feedback Queue)](#멀티레벨-피드백-큐multilevel-feedback-queue)
  - [다중처리기 스케쥴링](#다중처리기-스케쥴링)
  - [실시간 스케쥴링](#실시간-스케쥴링)
  - [스케쥴링 알고리즘 평가](#스케쥴링-알고리즘-평가)


---

# 버스트
기계어 명령
- 일반 명령
  - CPU 내에서 수행되는 명령
    - Add 명령
      - CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령
    - 이런 명령들은 CPU 내에서만 수행되므로 수행 속도가 빠르다.
  - 메모리 접근을 필요로 하는 명령
    - Load 명령
      - 메모리에 있는 데이터를 CPU로 읽어오는 명령
    - Store 명령
      - CPU에서 계산된 결괏값을 메모리에 저장하는 명령
      - CPU 내에서 수행되는 명령보다는 느리지만, 나름 수행 속도가 빠르다.
- 특권 명령
  - 입출력을 동반하는 명령
    - 대단히 오랜 시간 소요
    - 운영체제를 통해 대행한다.

프로그램의 수행은 서로 다른 두 단계의 조합으로 이루어진다.
- 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계
  - **CPU 버스트**
    - 프로그램이 I/O를 한 번 수행한 후 다음 번 I/O를 수행하기까지 직접 *CPU를 가지고 명령을 수행하는 일련의 작업*
- I/O요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계
  - **I/O 버스트**
    - I/O 작업이 요청된 후 완료되어 다시 CPU 버스트로 돌아가기까지 일어나는 일련의 작업

## 버스트 비율
- I/O 바운드 프로세스
  - I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
  - 사용자로부터 인터렉션을 계속 받아가며 프로그램을 수행
    - 대화형 프로그램(interactive program)
- CPU 바운드 프로세스 
  - I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스
  - 상당 시간을 CPU 작업에 소모하는 계산 위주의 프로그램

컴퓨터 시스템 내에서 수행되는 프로세스들의 CPU 버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가진다.
- CPU 스케쥴링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 하는 스케쥴링 필요
  - I/O 바운드 프로세스의 우선순위를 높여야 한다.

---

# 스케쥴러
CPU 스케쥴러
- 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드
- 비선점형(nonpreemptive) 방식
  - CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방식
- 선점형(preemptive) 방식
  - CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 방식
    - 빼앗는 방법
      - 할당 시간(time quantum)을 부여한 후 타이머 인터럽트를 발생시키는 방법

---

# 디스패처
CPU 스케쥴러가 어떤 프로세스에게 CPU를 할당할지 결정하고나서 CPU를 이양하는 작업이 필요한데, 이 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 **디스패처(dispatcher)** 라고 한다.
- 디스패처는 현재 수행 중이던 프로세스의 문맥을 프로세스의 PCB에 저장하고, 새로운 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행한다.
  - 이 때 걸리는 시간을 **디스패치 지연시간(dispatch latency)** 라고 한다.
    - 대부분은 문맥교환 오버헤드

---

# 스케쥴링의 성능 평가
## 시스템 관점의 지표
- CPU 이용률(CPU utilization)
  - 전체 시간 중에서 CPU가 일을 한 시간의 비율
- CPU 처리량(throughput)
  - 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스의 개수)
  - CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리


## 사용자 관점의 지표
- 소요시간(turnaround time)
  - 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸리는 시간
  - 준비 큐에서 기다린 시간 + CPU를 사용한 시간
- 대기시간(waiting time)
  - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
  - 타이머로 인해서 한 번의 CPU 버스트 기간 중에도 준비 큐에서 기다린 시간이 여러 번 발생할 수 있다.
- 응답시간(response time)
  - 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간
  - 대기시간과는 다르게 응답시간은 첫 CPU 획득까지 걸린 시간을 의미한다.

---

# 스케쥴링 알고리즘
## 선입선출 스케쥴링(First-Com First-Served: FCFS)
- 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식
- CPU 버스트가 긴 프로세스가 먼저 도착
  -  평균 대기시간이 길어지게 된다.
  -  CPU 버스트가 짧은 프로세스가 나중에 도착한다면 오랜 시간을 기다려야 하는 **콘보이 현상(Convoy effect)** 이 일어난다.
     -  FCFS 스케쥴링의 대표적인 단점
- CPU 버스트가 짧 프로세스가 먼저 도착
  - 평균 대기시간이 짧아지게 된다.

## 최단작업 우선 스케쥴링(Shortest-Job first: SJF)
- CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식
- 평균 대기시간이 가장 짧게 하는 최적 알고리즘(optimal algorithm)
- 두 가지 방식
  - 비선점형 방식
    - CPU 할당하면 끝날 때까지 무조건 기다리기
  - 선점형 방식
    - CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했어도, 중간에 더 짧은 프로세스가 온다면 CPU를 빼앗는다.
      - SRTF(Shortest Remaining Time First)
        - SJF 선점형 구현 방식
    - 평균 대기시간을 최소화하는 최적의 알고리즘
- SJF 스케쥴링 기법의 구현에서 현실적으로 어려운 부분은 프로세스의 *CPU 버스트 시간을 미리 알 수 없다는 점*이다.
  - 예측을 한다.
    - 과거를 통해 미래를 예측하는 데 있어서 더 오래된 과거일수록 그 영향력이 적어지도록 반영하는 방식
- 기아 현상(starvation)
  - CPU 버스트가 짧은 프로세스가 계속 들어와서 CPU 버스트가 긴 프로세스의 CPU 할당 기회가 계속 멀어지는 현상

## 우선순위 스케쥴링(priority scheduling)
- 준비 큐에서 기다리는 프로세스들 중에서 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식
  - 우선순위는 우선순위값(priority number)을 통해 표시
    - 우선순위값이 작을수록 높은 우선순위
  - 여러 가지 방식
    - CPU 버스트 시간: 우선순위
      - SJF 알고리즘과 동일
    - 시스템과 관련된 중요한 작업을 수행: 우선순위
- 선점형 방식
  - 우선순위가 더 높은 프로세스가 온다면 CPU를 넘긴다.
- 비선점형 방식
  - 끝날 때까지 기다린다.
- 기아 현상
  - 노화(aging) 기법으로 해결
    - 대기시간이 길어지면 우선순위를 조금씩 높여, 나중에 높은 우선순위를 갖게 한다.

## 라운드 로빈 스케쥴링(Round Robin Scheduling)
- 시분할 시스템의 성질을 가장 잘 활용
- 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 제한(할당시간, time quantum)
  - 시간이 경과하면 해당 프로세스는 준비 큐의 제일 뒤에 가서 줄을 선다.
- 할당시간이 너무 길면 FCFS
- 할당시간이 너무 짧으면 문맥교환 오버헤드가 커진다.
- 여러 종류의 이질적인 프로세스가 같이 실행되는 환경에서 효과적
  - 대화형 프로세스의 빠른 응답시간을 보장
- 기본적인 목적
  - CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있도록 하는 동시에, CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록 하는 것

## 멀티레벨 큐(multi-level queue)
- 준비 큐를 여러 개로 분할해 관리하는 스케쥴링 기법
- 성격이 다른 프로세스들을 별도로 관리하고, 프로세스의 성격에 맞는 스케쥴링을 적용하기 위해 준비 큐를 별도로 둔다.
  - 일반적으로 대화형 작업을 담기 위한 전위 큐(foreground queue)와 계산 위주의 작업을 담기 위한 후위 큐(background queue)로 분할하여 운영
    - 전위 큐에서는 응답시간을 짧게 하기 위해 라운드 로빈 스케쥴링 사용
    - 후위 큐에서는 응답시간이 큰 의미가 없기에 FCFS 스케쥴링 기법 사용
      - 문맥교환 오버헤드 감소 목적
- 큐 자체에 대한 스케쥴링
  - 여러 개의 큐에 대해서 어느 큐에 CPU를 먼저 할당할 것이냐를 결정해야 한다.
  - 고정 우선순위 방식(fixed priority scheduling)
    - 큐에 고정적인 우선순위를 부여해 우선순위가 높은 큐를 먼저 서비스하고 우선순위가 낮은 큐는 높은 큐가 비어 있을 때에만 서비스한다.
      - 전위 큐가 비어 있을 때에만 후위 큐 서비스
  - 타임 슬라이스(time slice)
    - 큐에 대한 기아 현상 방지
    - 각 큐에 CPU 할당 시간을 적절한 비율로 조절한다.

## 멀티레벨 피드백 큐(Multilevel Feedback Queue)
- CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티러벨 큐와 동일하나, 프로세스가 **하나의 큐에서 다른 큐로 이동 가능하다는 점**이 다르다.
- 정의하는 요소들
  - 큐의 수
  - 큐의 스케쥴링 알고리즘
  - 프로세스를 상위 큐로 승격시키는 기준
  - 프로세스를 하위 큐로 강등시키는 기준
  - 프로세스가 도착했을 때 들어갈 큐를 결정하는 기준

## 다중처리기 스케쥴링
- CPU가 여러 개인 시스템
- CPU가 하나일 때보다 더욱 복잡한 문제가 된다.
- 프로세스를 준비 큐에 한 줄로 세워서 CPU가 알아서 꺼내 가도록 할 수 있다.
  - 하지만 반드시 특정 CPU에서 처리해야 하는 프로세스가 있는 경우는 문제가 있다.
    - 각 CPU별로 줄 세우기 해야함
    - 편중되는 현상 발생
      - 부하균형(load balancing) 매커니즘 필요
        - 대칭형 다중처리(symmetric multi-processing)
          - 각 CPU가 각자 알아서 스케쥴링을 결정
        - 비대칭형 다중처리(asymmetric miltiprogramming)
          - 하나의 CPU가 다른 모든 CPU의 스케쥴링 및 데이터 접근을 책임진다.

## 실시간 스케쥴링
- 각 작업마다 주어진 데드라인이 있어 정해진 데드라인 안에 반드시 작업을 처리해야 한다.
- 실시간 시스템
  - 경성 실시간 시스템(hard real-time system)
    - 정해진 시간 안에 반드시 작업이 완료되어야 한다.
    - 미사일 발사, 원제로 제어 등
  - 연성 실시간 시스템(soft real-time system)
    - 데드라인이 있지만 이것을 지키지 못한다고 해서 위험한 상황이 발생하는 것은 아니다.
    - 스트리밍 시스템 등
- EDF(Eariest Deadline First) 스케쥴링
  - 데드라인이 얼마 남지 않은 요청을 먼저 처리한다.

## 스케쥴링 알고리즘 평가
- 큐잉모델(queueing model) - 이론가
  - 확률분포를 통해 프로세스들의 도착률, CPU의 처리율이 입력값
    - CPU의 처리량, 프로세스의 평균 대기시간 등을 구한다.
- 시뮬레이션(simulation)
  - 가상으로 CPU 스케쥴링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지 확인
  - 입력값은 가상으로 생성 가능하고 실제 시스템에서의 CPU 요청 내역을 추출해 사용할 수도 있다.
    - 트레이스(trace)
      - 실제 시스템에서 추출한 입력값
      - 몇 초에 어떤 프로세스가 도착하고, 각각 CPU버스트 시간을 얼마로 하는지에 대한 정보를 시간 순서대로 적어놓은 파일
- 구현 및 실축(implementation & measurement)   - 구현가
  - 운영체제 소스 코드 중 CPU 스케쥴링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치하는 과정이 필요
  - 동일한 프로그램을 원래 커널과 CPU 스케쥴러를 수정한 커널에서 수행시켜보고 실행시간을 측정