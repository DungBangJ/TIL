- [프로세스의 개념](#프로세스의-개념)
  - [프로세스의 문맥 세가지](#프로세스의-문맥-세가지)
- [프로세스의 상태](#프로세스의-상태)
- [프로세스 제어블록(Process Control Block, PCB)](#프로세스-제어블록process-control-block-pcb)
- [문맥교환(context switch)](#문맥교환context-switch)
- [프로세스를 스케쥴링하기 위한 큐](#프로세스를-스케쥴링하기-위한-큐)
  - [준비 큐(ready queue)](#준비-큐ready-queue)
  - [장치 큐(device queue)](#장치-큐device-queue)
  - [작업 큐(job queue)](#작업-큐job-queue)
- [스케쥴러](#스케쥴러)
  - [장기 스케쥴러(long term scheduler)](#장기-스케쥴러long-term-scheduler)
  - [단기 스케쥴러(short term scheduler)](#단기-스케쥴러short-term-scheduler)
  - [중기 스케쥴러(mediun term scheduling)](#중기-스케쥴러mediun-term-scheduling)
    - [중지 상태](#중지-상태)
- [프로세스의 생성](#프로세스의-생성)
  - [자식, 부모 프로세스](#자식-부모-프로세스)
    - [자원 획득 방법](#자원-획득-방법)
  - [프로세스 종료는 두 가지로 나눈다.](#프로세스-종료는-두-가지로-나눈다)
    - [**자발적 종료**<br/>](#자발적-종료)
    - [**비자발적 종료**<br/>](#비자발적-종료)
  - [자식 프로세스 생성법](#자식-프로세스-생성법)
- [프로세스 간의 협력](#프로세스-간의-협력)
  - [IPC(Inter-Process Communication)](#ipcinter-process-communication)
    - [메세지 전달 방식](#메세지-전달-방식)
    - [공유 메모리 방식(shared memory)](#공유-메모리-방식shared-memory)
    
    


---

# 프로세스의 개념
- **실행 중인 프로그램**(program in execution)
- 프로세스의 문맥(context)
  - 프로세스가 어떤 상태인지에 대한 정보
  - CPU 제어권을 인터럽트에게 잠시 뺏겼다가 직전 수행시점에서 다시 시작할 때 정확한 상태를 재현할 필요가 있다.
    - 이때 필요한 정보가 프로세스의 문맥
  - 프로세스의 주소 공간(코드, 데이터, 스택), 레지스터값, 커널이 관리하는 정보 등을 포함

## 프로세스의 문맥 세가지
- 하드웨어 문맥
  - CPU의 수행 상태를 나타내느 것
    - 프로그램 카운터값
    - 각종 레지스터값
- 프로세스의 주소 공간
  - 코드, 데이터, 스택으로  구성되는 자기만의 독자적인 주소 공간
- 커널상의 문맥
  - 프로세스를 관리하기 위한 자료구조

---

# 프로세스의 상태
컴퓨터 자원을 효율적으로 관리하기 위해서 프로세스의 상태를 세가지로 나눈다.
- 실행(running)
  - 프로세스가 CPU 보유
  - 기계어 명령을 실행하고 있는 상태
- 준비(ready)
  - 프로세스가 명령을 실행할 수 있는 준비 상태
- 봉쇄(blocked, wait, sleep)
  - CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태

문맥교환(context switch)
- 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정
- CPU 디스패치(dispatch)
  - 준비 상태에 있는 프로세스가 CPU의 제어권을 넘겨받는 과정

---

# 프로세스 제어블록(Process Control Block, PCB)
- 운영체제가 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
- PCB 요소들
  - 프로세스의 상태(process state)
    - CPU를 할당해도 되는지 여부를 결정
  - 프로그램 카운터(program counter)의 값
    - 다음에 수행할 명령의 위치
  - CPU 레지스터(CPU register) 값
    - CPU 연산을 위해 현 시점에 레지스터에 어떤값을 저장하고 있는지
  - CPU 스케쥴링 정보(CPU scheduling information)
  - 메모리 관리 정보(memory management information)
  - 자원 사용 정보(accounting information)
  - 입출력 상태 정보(I/O status information)
    - 프로세스의 입출력 관련 상태 정보

---

# 문맥교환(context switch)
- 어떤 프로세스로부터 다른 프로세스로 CPU의 제어권이 이양되는 과정
- 문맥교환 중에 프로세스의 문맥을 저장하고, 새롭게 PCB로부터 하드웨어로 복원시키는 과정을 거친다.
- 문맥교환은 CPU를 점유하는 프로세스가 다른 사용자 프로세스로 넘어갈 때만 일어난다.
  - 실행모드가 바뀌는 것은 문맥교환이 아니다.
    - 실행모드가 바뀌는 것보다 문맥교환이 더 많은 오버헤드(overhead)가 뒤따른다.

---

# 프로세스를 스케쥴링하기 위한 큐
## 준비 큐(ready queue)
  - 준비 상태에 있는 프로세스들의 줄
## 장치 큐(device queue)
  - 특정 자원을 기다리는 프로세스들의 줄
  - 봉쇄상태
## 작업 큐(job queue)
  - 시스템 내의 모든 프로세스를 관리
  - 준비 큐와 장치 큐가 작업 큐에 속한다.

---

# 스케쥴러
- 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드
## 장기 스케쥴러(long term scheduler)
  - 작업 스케쥴러(job scheduler)라고도 부른다.
  - 어떤 프로세스를 준비 큐에 진입시킬지 결정<br/>(시작 상태의 프로세스를 실행 상태로 만들 것인지 - 메모리 할당)
  - 메모리에 동시에 올라가 있는 프로세스의 수를 조절


## 단기 스케쥴러(short term scheduler)
  - CPU 스케쥴러라고도 부른다.
  - 준비 상태의 프로세스 중에서 실행 상태로 만들 프로세스를 결정<br/>(준비 큐에 있는 프로세스들 중 어떤 것을 CPU에 할당할 것인가를 결정)
  - 수행 속도가 빨라야 한다.

## 중기 스케쥴러(mediun term scheduling)
- 메모리에 적재된 프로세스의 수를 동적으로 조절
  - 부족할 경우 메모리를 빼앗아 그 내용을 디스크의 스왑 영역에 저장해둔다.
  - 0순위 스왑 아웃 대상은 봉쇄 상태에 있는 프로세스들
  - 그 다음 스왑 아웃 대상은 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스들
  - 중기스케쥴러의 등장으로 프로세스의 상태는 실행, 준비, 봉쇄, ***중지(suspended, stopped)*** 가 되었다.

### 중지 상태
- 중지 상태에 있는 프로세스는 외부에서 재개시키지 않는 이상 재활성화될 수 없으므로 메모리가 당장 필요하지는 않다.
- 중지 상태의 프로세스는 메모리를 통째로 빼앗기고 스왑 아웃된다.
  - 중지준비 상태
    - 준비상태의 프로세스가 스왑 아웃된 상태
  - 중지봉쇄 상태
    - 봉쇄 상태였던 프로세스가 스왑 아웃된 상태

---

# 프로세스의 생성
시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성한다.<br/>
그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성한다.
- 이때 프로세스를 생성한 프로세스를 부모 프로세스, 생성된 프로세스를 자식 프로세스라고 한다.
- 자식 프로세스가 먼저 죽는다.

## 자식, 부모 프로세스
### 자원 획득 방법
- 자식, 부모가 공존하는 프로세스는 CPU를 획득하기 위해 경쟁한다.
- 자식을 기다리는 부모 모델은 봉쇄 상태로 있다가(wait()) 자식 프로세스가 종료되면 그제서야 준비 상태가 되어 CPU를 얻을 권한이 생긴다.
- 프로세스가 생성되면 자신만의 주소 공간(address apace)가 생기는데 자식 프로세스는 부모 프로세스의  주소 공간 내용을 그대로 복사해서 생성한다.
  - 자식 프로세스가 다른 프로그램을 수행하기 위해서는 생성된 주소 공간 위에 새로운 프로그램의 주소 공간을 덮어씌워 실행하게 되는 것이다.

## 프로세스 종료는 두 가지로 나눈다.
### **자발적 종료**<br/>
마지막 명령을 수행한 후에 운영체제에게 이를 알린다. 
- exit();
  - 시스템 콜      
  - 이 시스템 콜로 운영체제에게 자기가 종료됨을 알리는 것이다.
    - 이게 없어도 컴파일러가 자동으로 삽입해 프로세스 종료 직전에 항상 호출한다.
- 운영체제는 자원을 회수하고 시스템 내에서 이 프로세스를 정리하게 한다.

### **비자발적 종료**<br/>
부모 프로세스가 자식 프로세스를 강제로 종료시키는 것
- abort();
  - 자식 프로세스가 할당 자원의 한계치가 넘는 자원을 요구할 때
  - 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
  - 부모 프로세스가 종료(exit)되는 경우

## 자식 프로세스 생성법
- 운영체제는 자식 프로세스 생성을 위해 fork() 시스템 콜을 제공한다.
- 프로세스가 fork() 시스템 콜을 하게 되면 CPU의 제어권이 커널로 넘어가고, 커널은 fork()를 호출한 프로세스를 복제해 자식 프로세스를 생성한다.
- fork()의 함숫값(이것으로 둘을 구분)
  - 자식 프로세스: 0
  - 부모 프로세스: 1
- 함숫값이 달라도 조건문에 의한 분기(branch)일 뿐 사실상 두 프로세스 모두 동일한 코드 내용을 가진다.
  - 독자적인 프로그램을 수행시키기 위해 유닉스에서는 **exec()** 시스템 콜을 지원한다.
    - 프로세스의 주소 공간에 새로운 프로그램을 덮어씌우는 것<br/>(완전 새로운 프로그램으로 만들기)

---

# 프로세스 간의 협력
경우에 따라서는 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있다.
## IPC(Inter-Process Communication)
- 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간의 통신
  - 의사소통 기능과 동기화를 보장해줘야 한다.
### 메세지 전달 방식
  - 프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고 받으면서 통신하는 방식
  - 커널이 우체국 역할: send(message), receive(message)
  - 두 프로세스는 시스템 콜 방식으로 메시지 전달 요청을 할 수 있다.
  - 직접 통신(direct communication)
    - 통신하려는 프로세스의 이름을 명시적으로 표시
      - send(P, message): P에게 보내기
      - receive(Q, message): Q로부터 받기
  - 간접 통신(indirect communication)
    - 중간의 메일박스나 포트로부터 전달받는다.
    - 메일박스의 이름 표시
      - send(A, message): 메일박스 A에게 보내기
### 공유 메모리 방식(shared memory)
프로세스들이 주소 공간 일부를 공유한다.
- 운영체제가 공유메모리를 사용하는 시스템 콜을 지원해, 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유할 수 있도록 한다.
- 문제가 많이 일어날 수 있음