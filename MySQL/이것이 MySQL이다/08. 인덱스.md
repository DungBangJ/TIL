- [인덱스의 개념](#인덱스의-개념)
- [인덱스의 종류와 자동 생성](#인덱스의-종류와-자동-생성)
  - [인덱스의 종류](#인덱스의-종류)
  - [자동으로 생성되는 인덱스](#자동으로-생성되는-인덱스)
- [인덱스의 내부 작동](#인덱스의-내부-작동)
  - [B-REE(Balanced Tree, 균형 트리)](#b-reebalanced-tree-균형-트리)
  - [페이지 분할](#페이지-분할)
  - [클러스터형 인덱스와 보조 인덱스의 구조](#클러스터형-인덱스와-보조-인덱스의-구조)
  - [클러스터형 인덱스와 보조 인덱스가 혼합되어 있을 경우](#클러스터형-인덱스와-보조-인덱스가-혼합되어-있을-경우)

---

# 인덱스의 개념
데이터를 좀 더 빠르게 찾을 수 있도록 해주는 도구
- 튜닝(tuning)에 즉각적인 효과
  - 인덱스를 생성하고 사용하는 SQL을 만들어 사용하면 기존보다 빠르다.
  - 전체적인 성능 향상

---

# 인덱스의 종류와 자동 생성

## 인덱스의 종류
- 클러스터형 인덱스(clustered index)
  - 영어 사전
    - 사전처럼 책의 내용 자체가 순서대로 정렬
  - 테이블을 한 개만 생성 가능
  - 행 데이터를 자신의 열을 기준으로 정렬한다.(오름차순)
  - 보조 인덱스보다 검색 속도가 더 빠르다.

- 보조 인덱스(secondary index)
  - <찾아보기>가 있는 일반 책
    - 해당 페이지로 가야 내용이 있다.
  - 여러 테이블 생성 가능

## 자동으로 생성되는 인덱스
인덱스는 테이블의 열(컬럼) 단위에 생성된다.
- 예를 들어, 테이블에 8개의 열이 있다면 8개 인덱스를 생성할 수 있다.

```sql
CREATE TABLE usertbl
(
    userID char(8) NOT NULL PRIMARY KEY,
    name varchar(10) NOT NULL,
    birthYear int NOT NULL,
    ...
)
```
- 이렇게 PRIMARY KEY로 지정하면 자동으로 userID열에 클러스터형 인덱스가 생성된다.
  - '클러스터형 인덱스'와 'Primary key 인덱스'는 거의 동일한 용어
  - 한 테이블에 하나만 생성 가능
- 테이블 생성 시에 제약 조건 Primary Key 또는 Unique를 사용하면 자동으로 인덱스가 생성된다.

클러스터형 인덱스 생성
```sql
CREATE TABLE tbl1
(
    a INT PRIMARY KEY,
    b INT,
    c INT
)
```

보조 인덱스 생성
```sql
CREATE TABLE tbl2
(
    a INT PRIMARY KEY,
    b INT UNIQUE,
    c INT UNIQUE,
    d INT
)
```

보조 인덱스를 클러스터형 인덱스로 변경
- UNIQUE에 NOT NULL을 추가하면 된다.
```sql
CREATE TABLE tbl3
(
    a INT UNIQUE NOT NULL, -- 보조 인덱스 -> 클러스터형 인덱스
    b INT UNIQUE,
    c INT UNIQUE,
    d INT
)
```

보조 인덱스에 NOT NULL을 추가해도 PRIMARY KEY가 있는 열이 클러스터형 인덱스가 된다.
```sql
CREATE TABLE tbl4
(
    a INT UNIQUE NOT NULL, -- 클러스터형 인덱스 -> 보조 인덱스
    b INT UNIQUE,
    c INT UNIQUE,
    d INT PRIMARY KEY -- 클러스터형 인덱스
)
```

---

# 인덱스의 내부 작동
## B-REE(Balanced Tree, 균형 트리)
주로 인덱스를 표현할 때 사용한다.
- 데이터 검색에 높은 성능

노드(Node)
- 트리 구조에서 데이터가 존재하는 공간
- 루트 노드
  - 가장 상위 노드
- 리드 노드
  - 제일 마지막에 존재하는 노드
- 중간 수준 노드
  - 루트 노드와 리드 노드 중간에 끼인 노드들
- 페이지(page) = 노드
  - 16Kbyte 크기의 최소한의 저장 단위
  - 작은 데이터 하나라도 한 페이지를 차지하게 된다.
- 인덱스를 구현할 때 기본적으로 B-Tree 구조를 사용

## 페이지 분할
인덱스를 구성하면 SELECT의 속도가 급격히 향상된다.

하지만 인덱스를 구성하면 데이터의 변경 작업(INSERT, UPDATE, DELETE) 시에 성능이 나빠진다.
- 페이지 분할 때문
  - 데이터를 계속 입력해서 루트 페이지와 리프 페이지의 용량이 부족한 경우가 생긴다.
    - 이럴 경우에 새로운 페이지를 만들어낸다.(페이지 분할)
    - 페이지가 계속 분할되면서 늘어나면 작업 속도가 느려진다.

>MySQL의 페이지 크기 확인<br/>
>SHOW VARIABLES LIKE 'innodb_page_size'

## 클러스터형 인덱스와 보조 인덱스의 구조

클러스터형 인덱스
- 클러스터형 인덱스를 구성하기 위해서 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만든다.
- 루트 페이지와 인덱스 페이지로 인덱스가 구성
  - 리프 페이지 = 데이터 페이지

![](mysqlimg/2022-01-27-16-11-07.png)

- 클러스터 인덱스에 새로운 데이터 입력
  - 리프 페이지가 페이지 분할이 일어난다.
  - 루트 페이지 순서가 약간 변경


![](mysqlimg/2022-01-27-16-17-52.png)

보조 인덱스
- 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성한다.
- 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬한다.
- 데이터 위치 포인터 생성
  - 주소값(페이지 번호 + #오프셋)이 기록되어 바로 데이터의 위치를 가리킨다.
  - 데이터가 위치한 고유한 값

![](mysqlimg/2022-01-27-16-07-32.png)

- 보조 인덱스에 새로운 데이터 입력
  - 보조 인덱스는 데이터 페이지를 정렬하지 않는다.
  - 테이터 페이지 뒤쪽 빈 부분에 삽입
  - 리프 페이지에도 약간의 위치 조정
  - 페이지 분할은 일어나지 않는다.
  - 클러스터 인덱스보다 데이터 입력에서는 성능에 주는 부하가 더 적었다.


보통 검색 속도는 클러스터형 인덱스가 보조 인덱스보다 빠르다.
- 클러스터형 인덱스는 루트 페이지와 리프 페이지 2개만 읽는다.
  - 보조 인덱스는 루트, 리프 페이지, 데이터 페이지를 읽어 총 3개를 읽는다.


|      인덱스       | 특징                                                                                                                                                                                                                                                                                                                                                                |
| :---------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 클러스터형 인덱스 | 클러스터형 인덱스의 생성 시에는 데이터 페이지 전체가 다시 정렬된다.<br/>인덱스 자체의 리프 페이지가 곧 데이터이므로, 인덱스 자체에 데이터가 포함되어 있다고 볼 수 있다.<br/>보조 인덱스보다 검색속도는 빠르지만, 데이터의 입력/수정/삭제는 느리다.<br/>테이블에 한 개만 생성할 수 있고, 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라진다. |
|    보조 인덱스    | 보조 인덱스의 생성 시에는 별도의 페이지에 인덱스를 구성한다.<br/>인덱스 자체의 리프 페이지는 데이터가 아니라 테이터가 위치하는 주소값(RID)이다.<br/>클러스터형보다 검색 속도는 느리지만, 데이터의 입력/수정/삭제는 빠르다.<br/>보조 인덱스는 여러 개 생성 가능하지만, 남용할 경우에는 오히려 시스템의 성능을 저하시킨다.                                            |

## 클러스터형 인덱스와 보조 인덱스가 혼합되어 있을 경우
독립되어 있는 것보다 혼합되어 있는 경우가 더 많다.
- 클러스터형 인덱스를 생성하고, 보조 인덱스를 생성할 경우
  - 보조 인덱스의 루트 페이지와 리프 페이지의 키 값이 이름으로 구성되어 있다면 일단 이름으로 정렬된다.
  - 보조 인덱스의 리프 페이지
    - 원래는 '데이터 페이지의 주소값'으로 구성되어 있다.
      - 혼합 상태에서는 클러스터형 인덱스의 키 값을 가지게 된다.
  - 만약 보조 인덱스에서 검색을 한다면, 어차피 모두 다시 클러스터형 인덱스의 루트 페이지부터 검색한다.

보조 인덱스와 혼합되어 사용되는 경우에는 되도록이면 클러스터형 인덱스로 설정할 열은 적은 자릿수의 열을 선택하는 것이 바람직하다.

인덱스를 검색하기 위한 일차 조건은 WHERE절에 해당 인덱스를 생성한 열의 이름이 나와야 한다.